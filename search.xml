<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>代理模式</title>
    <url>/2021/05/08/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式的定义"><a href="#代理模式的定义" class="headerlink" title="代理模式的定义"></a>代理模式的定义</h1><p>定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。</p>
<p>这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理分两类：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<h1 id="静态代理的结构与实现"><a href="#静态代理的结构与实现" class="headerlink" title="静态代理的结构与实现"></a>静态代理的结构与实现</h1><p>静态代理模式包含以下主要角色:</p>
<ol>
<li>抽象角色 : 一般使用接口或者抽象类来实现</li>
<li>真实角色 : 被代理的角色</li>
<li>代理角色 : 代理真实角色 ; 代理真实角色后 , 一般会做一些附属的操作 .</li>
<li>客户  :  使用代理角色来进行一些操作 .</li>
</ol>
<p>实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色  出租房子(业务)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实角色  房东，出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代理也有出租业务,通过房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Host host;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(Host host)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.host = host;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        host.rent();<span class="comment">//代理了房东出租业务</span></span><br><span class="line">        fare();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//也可以扩展业务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收取中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类即房客类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//房东出租房屋</span></span><br><span class="line">        Host host = <span class="keyword">new</span> Host();</span><br><span class="line">        <span class="comment">//代理接受业务</span></span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy(host);</span><br><span class="line">        <span class="comment">//房客通过代理(中介)租到房子</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="静态代理的优点"><a href="#静态代理的优点" class="headerlink" title="静态代理的优点:"></a>静态代理的优点:</h2><ol>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
</ol>
<h2 id="静态代理的缺点："><a href="#静态代理的缺点：" class="headerlink" title="静态代理的缺点："></a>静态代理的缺点：</h2><ol>
<li>类多了 , 多了代理类 , 工作量变大了 . 开发效率降低 </li>
<li>会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
</ol>
<p>想要静态代理的好处，又不想要静态代理的缺点，所以 , 就有了动态代理 !</p>
<h1 id="动态代理的结构与实现"><a href="#动态代理的结构与实现" class="headerlink" title="动态代理的结构与实现"></a>动态代理的结构与实现</h1><ul>
<li><p>动态代理的角色和静态代理的一样 .</p>
</li>
<li><p>动态代理的代理类是动态生成的 ，静态代理的代理类是我们提前写好的</p>
</li>
<li><p>动态代理分为两类 : 一类是基于接口动态代理 , 一类是基于类的动态代理</p>
<ul>
<li>基于接口的动态代理—-JDK动态代理</li>
<li>基于类的动态代理–cglib</li>
<li>现在用的比较多的是 javasist 来生成动态代理 . 百度一下javasist</li>
</ul>
</li>
</ul>
<p><strong>JDK动态代理需要了解两个类： InvocationHandler 和 Proxy</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object proxy, 方法 method, Object[] args)</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//参数</span></span></span><br><span class="line"><span class="function"><span class="comment">//proxy - 调用该方法的代理实例</span></span></span><br><span class="line"><span class="function"><span class="comment">//method -所述方法对应于调用代理实例上的接口方法的实例。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口。</span></span></span><br><span class="line"><span class="function"><span class="comment">//args -包含的方法调用传递代理实例的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实例中，例如java.lang.Integer或java.lang.Boolean </span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成代理类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;   </span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),                                 		 					rent.getClass().getInterfaces(),<span class="keyword">this</span>);&#125;</span><br></pre></td></tr></table></figure>

<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抽象角色  出租房子(业务)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rent</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真实角色  房东，出租房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Host</span> <span class="keyword">implements</span> <span class="title">Rent</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;房屋出租&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//动态代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Rent rent;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRent</span><span class="params">(Rent rent)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rent = rent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//生成代理类，重点是第二个参数，获取要代理的抽象角色！之前都是一个角色，现在可以代理一类角色</span></span><br><span class="line">    <span class="comment">//原因在于代理的是接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                rent.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 代理类的调用处理程序的方法对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        seeHouse();</span><br><span class="line">        <span class="comment">//核心：本质利用反射实现！</span></span><br><span class="line">        Object obj = method.invoke(rent, args);</span><br><span class="line">        fare();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//看房</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">seeHouse</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;带房客看房&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//收中介费</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fare</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收中介费&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类即房客类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Host host = <span class="keyword">new</span> Host();<span class="comment">//真实角色</span></span><br><span class="line">        <span class="comment">//代理实例的调用处理程序</span></span><br><span class="line">        ProxyInvocationHandler pih = <span class="keyword">new</span> ProxyInvocationHandler();</span><br><span class="line">        pih.setRent(host);<span class="comment">//将真实角色放置进去！</span></span><br><span class="line">        Rent proxy = (Rent) pih.getProxy();<span class="comment">//动态生成对应的代理类！</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="动态代理模板"><a href="#动态代理模板" class="headerlink" title="动态代理模板"></a>动态代理模板</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//动态代理模板</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DyProxyTemplate</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(<span class="keyword">this</span>.getClass().getClassLoader(),</span><br><span class="line">                                      target.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="动态代理的优点"><a href="#动态代理的优点" class="headerlink" title="动态代理的优点"></a>动态代理的优点</h2><p>静态代理有的它都有，静态代理没有的，它也有！</p>
<ul>
<li>可以使得我们的真实角色更加纯粹 . 不再去关注一些公共的事情 .</li>
<li>公共的业务由代理来完成 . 实现了业务的分工 ,</li>
<li>公共业务发生扩展时变得更加集中和方便 .</li>
<li>一个动态代理 , 一般代理某一类业务</li>
<li>一个动态代理可以代理多个类，代理的是接口！</li>
</ul>
<h1 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h1><ul>
<li>远程代理，这种方式通常是为了隐藏目标对象存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</li>
<li>虚拟代理，这种方式通常用于要创建的目标对象开销很大时。例如，下载一幅很大的图像需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</li>
<li>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</li>
<li>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</li>
<li>延迟加载，指为了提高系统的性能，延迟对目标的加载。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2021/05/06/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="单例模式的定义与特点"><a href="#单例模式的定义与特点" class="headerlink" title="单例模式的定义与特点"></a>单例模式的定义与特点</h1><p>定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式</p>
<p>单例模式的运用十分广泛，比如J2EE 标准中的 ServletContext 和 ServletContextConfig、Spring框架应用中的 ApplicationContext、数据库中的连接池等也都是单例模式。</p>
<p>单例模式的三个特点：</p>
<ol>
<li>单例类只有一个实例对象</li>
<li>该单例对象必须由单例类自行创建</li>
<li>单例类对外提供一个访问改单例的全局访问点</li>
</ol>
<h1 id="单例模式的优缺点"><a href="#单例模式的优缺点" class="headerlink" title="单例模式的优缺点"></a>单例模式的优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>单例模式可以保证内存里只有一个实例，减少了内存的开销。</li>
<li>可以避免对资源的多重占用。</li>
<li>单例模式设置全局访问点，可以优化和共享资源的访问。</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>单例模式一般没有接口，扩展困难。如果要扩展，则除了修改原来的代码，没有第二种途径，违背开闭原则。</li>
<li>在并发测试中，单例模式不利于代码调试。在调试过程中，如果单例中的代码没有执行完，也不能模拟生成一个新的对象。</li>
<li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li>
</ul>
<h1 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h1><p>对于 Java 来说，单例模式可以保证在一个 JVM 中只存在单一实例。单例模式的应用场景主要有以下几个方面。</p>
<ul>
<li>需要频繁创建的一些类，使用单例可以降低系统的内存压力，减少 GC。</li>
<li>某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。</li>
<li>某些类创建实例时占用资源较多，或实例化耗时较长，且经常使用。</li>
<li>某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。</li>
<li>频繁访问数据库或文件的对象。</li>
<li>对于一些控制硬件级别的操作，或者从系统上来讲应当是单一控制逻辑的操作，如果有多个实例，则系统会完全乱套。</li>
<li>当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。</li>
</ul>
<h1 id="单例模式的结构与实现"><a href="#单例模式的结构与实现" class="headerlink" title="单例模式的结构与实现"></a>单例模式的结构与实现</h1><p>单例模式是设计模式中最简单的模式之一。通常，普通类的构造函数是公有的，外部类可以通过“new 构造函数()”来生成多个实例。而单例模式的构造函数都是私有的，对外提供一个静态的公有函数用于创建或获取该静态私有实例</p>
<h2 id="1-单例模式的结构"><a href="#1-单例模式的结构" class="headerlink" title="1.单例模式的结构"></a>1.单例模式的结构</h2><p>.单例模式的主要角色如下。</p>
<ul>
<li>单例类：包含一个实例且能自行创建这个实例的类。</li>
<li>访问类：使用单例的类。</li>
</ul>
<h2 id="2-单例模式的实现"><a href="#2-单例模式的实现" class="headerlink" title="2.单例模式的实现"></a>2.单例模式的实现</h2><blockquote>
<p>饿汉式单例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Hungry hungrySingle = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hungrySingle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>懒汉式单例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;</span><br><span class="line">            lazyMan = <span class="keyword">new</span> LazyMan();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在线程安全问题，单线程是安全，进一步改进=&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line">	<span class="comment">//双重检测模式的懒汉单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双重检测模式虽然更安全但是还存在指令重排的问题，因为不是一个原子性操作，进一步改进=&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyMan</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">	<span class="comment">//加关键字volatile，保证内存可见性，不会发生指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> LazyMan lazyMan;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazyMan <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    lazyMan = <span class="keyword">new</span> LazyMan();</span><br><span class="line">                    <span class="comment">/**执行流程  存在问题</span></span><br><span class="line"><span class="comment">                    * 1、分配内存空间</span></span><br><span class="line"><span class="comment">                    * 2、执行构造方法，初始化对象</span></span><br><span class="line"><span class="comment">                    * 3、把这个对象执行这个空间</span></span><br><span class="line"><span class="comment">                    * 正确顺序 123   指令重排会132</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lazyMan;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>虽然此时懒汉式单例已经很安全了，但是在java反射面前依然是不安全的</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//测试一下</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        LazyMan instance1 = LazyMan.getInstance();</span><br><span class="line">        Constructor&lt;LazyMan&gt; declaredConstructor = LazyMan.class.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">        declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        LazyMan instance2 = declaredConstructor.newInstance();</span><br><span class="line">        System.out.println(instance1);<span class="comment">//single.LazyMan@4554617c</span></span><br><span class="line">        System.out.println(instance2);<span class="comment">//single.LazyMan@74a14482</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>此时单例明显被破坏了，需要进一步改进=&gt;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在构造器中加锁判断</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazyMan</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (LazyMan.class)&#123;</span><br><span class="line">        <span class="keyword">if</span> (lazyMan == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;不要尝试用反射破坏单例模式&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









<blockquote>
<p>静态内部类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态内部类单例的持有者</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingle</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> InnerClass INSTANCE = <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClass <span class="title">getSingleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerSingle.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>枚举单例</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//jdk 1.5 出来的</span></span><br><span class="line"><span class="comment">//enum 本身也是一个class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span>  <span class="title">EnumSingle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ENUM_SINGLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> EnumSingle <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ENUM_SINGLE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最完美的单例实现，尝试使用反射破坏</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    EnumSingle instance1 = EnumSingle.ENUM_SINGLE;</span><br><span class="line">    EnumSingle instance2 = EnumSingle.ENUM_SINGLE;</span><br><span class="line">    System.out.println(instance1);<span class="comment">//输出同一个对象</span></span><br><span class="line">    System.out.println(instance2);<span class="comment">//未被破坏</span></span><br><span class="line">    <span class="comment">//Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor();</span></span><br><span class="line">    Constructor&lt;EnumSingle&gt; declaredConstructor = EnumSingle.class.getDeclaredConstructor(String.class,<span class="keyword">int</span>.class);</span><br><span class="line">    declaredConstructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    EnumSingle enumSingle = declaredConstructor.newInstance();</span><br><span class="line">    System.out.println(enumSingle);<span class="comment">//抛出一个异常java.lang.NoSuchMethodException与预期异常不符合</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题分析：</p>
<ul>
<li>枚举类底层其实也是class, 集成了 Enum</li>
<li>idea 编译结果 和 javap -p xxx.class 反编译,也是 无参的私有构造, 欺骗了我们</li>
<li>使用jad 工具, 底层其实是 有参的 私有构造 参数为 String , int 俩个</li>
<li>结果得到了 我们的 异常 Cannot reflectively create enum objects</li>
<li>declaredConstructor.newInstance(); 源码分析 为 : 为枚举类的时候, 不能create enum objects</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol>
<li>一般情况下，懒汉式（包含线程安全和线程不安全方式）都比较少用；</li>
<li>饿汉式和双检锁都可以使用，可根据具体情况自主选择；</li>
<li>在要明确实现 lazy loading 效果时，可以考虑静态内部类的实现方式；</li>
<li>若涉及到反序列化创建对象时，大家也可以尝试使用枚举方式。</li>
</ol>
<p>要想实现效率高的线程安全的单例，我们必须注意以下两点：</p>
<ul>
<li><strong>尽量减少同步块的作用域；</strong></li>
<li><strong>尽量使用细粒度的锁。</strong></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>单例模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2021/05/07/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="原型模式的定义"><a href="#原型模式的定义" class="headerlink" title="原型模式的定义"></a>原型模式的定义</h1><p>定义:用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象</p>
<p>原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。</p>
<h1 id="原型模式的优缺点"><a href="#原型模式的优缺点" class="headerlink" title="原型模式的优缺点"></a>原型模式的优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。</li>
<li>可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>需要为每一个类都配置一个 clone 方法</li>
<li>clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。</li>
<li>当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。</li>
</ul>
<h1 id="原型模式的应用场景"><a href="#原型模式的应用场景" class="headerlink" title="原型模式的应用场景"></a>原型模式的应用场景</h1><p>原型模式通常适用于以下场景。</p>
<ul>
<li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li>
<li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li>
<li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li>
<li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li>
</ul>
<p>在 Spring中，原型模式应用的非常广泛，例如 scope=’prototype’、JSON.parseObject() 等都是原型模式的具体应用。</p>
<h1 id="原型模式的结构与实现"><a href="#原型模式的结构与实现" class="headerlink" title="原型模式的结构与实现"></a>原型模式的结构与实现</h1><p>原型模式包含以下主要角色。</p>
<ol>
<li>抽象原型类：规定了具体原型对象必须实现的接口。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ol>
<p>原型模式的克隆分为浅克隆和深克隆。模式的实现:</p>
<ol>
<li>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</li>
<li>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</li>
</ol>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Video类  get、set、无参有参构造、toString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line">    <span class="comment">/*实现克隆步骤</span></span><br><span class="line"><span class="comment">    1.实现一个接口 Cloneable</span></span><br><span class="line"><span class="comment">    2.重写一个方法 clone()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">//调用了本地方法clone</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoWeb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//原型对象 v1</span></span><br><span class="line">        Video v1 = <span class="keyword">new</span> Video(<span class="string">&quot;视频1&quot;</span>, date);</span><br><span class="line">        System.out.println(<span class="string">&quot;v1=&gt;&quot;</span>+v1);</span><br><span class="line">        System.out.println(<span class="string">&quot;v1=&gt;hash:&quot;</span>+v1.hashCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//v2 克隆 v1</span></span><br><span class="line">        Video v2 = (Video) v1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;v2=&gt;&quot;</span>+v2);</span><br><span class="line">        System.out.println(<span class="string">&quot;v2=&gt;hash:&quot;</span>+v2.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时控制台输出是</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*v1=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 19:44:43 CST 2021&#125;</span></span><br><span class="line"><span class="comment">  v1=&gt;hash:21685669</span></span><br><span class="line"><span class="comment">  v2=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 19:44:43 CST 2021&#125;</span></span><br><span class="line"><span class="comment">  v2=&gt;hash:2133927002</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以发现v1与v2属性是相同的但是hashcode是不同的，是两个不同的对象,但是这种克隆存在一个问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoWeb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        <span class="comment">//原型对象 v1</span></span><br><span class="line">        Video v1 = <span class="keyword">new</span> Video(<span class="string">&quot;视频1&quot;</span>, date);</span><br><span class="line">        <span class="comment">//v2 克隆 v1</span></span><br><span class="line">        Video v2 = (Video) v1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;v1=&gt;&quot;</span>+v1);</span><br><span class="line">        System.out.println(<span class="string">&quot;v2=&gt;&quot;</span>+v2);</span><br><span class="line">        <span class="comment">//修改了date</span></span><br><span class="line">        date.setTime(<span class="number">123456789</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;v1=&gt;&quot;</span>+v1);</span><br><span class="line">        System.out.println(<span class="string">&quot;v2=&gt;&quot;</span>+v2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时控制台输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v1=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 20:09:27 CST 2021&#125;</span></span><br><span class="line"><span class="comment">v2=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 20:09:27 CST 2021&#125;</span></span><br><span class="line"><span class="comment">v1=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri Jan 02 18:17:36 CST 1970&#125;</span></span><br><span class="line"><span class="comment">v2=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri Jan 02 18:17:36 CST 1970&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以明显发现，date修改后，v1v2的值也修改了，这说明v1和v2两个对象指向的是同一个内存地址,这是<strong>浅克隆</strong>，这种情况往往不是我们需要的，所以需要<strong>深克隆</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Video类 get、set、无参有参构造、toString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Video</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//实现深克隆</span></span><br><span class="line">        Video v = (Video) obj;</span><br><span class="line">        v.createTime = (Date) <span class="keyword">this</span>.createTime.clone();</span><br><span class="line">        <span class="comment">//除了此方法进行深克隆  还可以通过序列化、反序列化</span></span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoWeb</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        Video v1 = <span class="keyword">new</span> Video(<span class="string">&quot;视频1&quot;</span>, date);</span><br><span class="line">        Video v2 = (Video) v1.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;v1=&gt;&quot;</span>+v1);</span><br><span class="line">        System.out.println(<span class="string">&quot;v2=&gt;&quot;</span>+v2);</span><br><span class="line">        date.setTime(<span class="number">123456789</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;v1=&gt;&quot;</span>+v1);</span><br><span class="line">        System.out.println(<span class="string">&quot;v2=&gt;&quot;</span>+v2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时控制台输出:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">v1=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 20:16:58 CST 2021&#125;</span></span><br><span class="line"><span class="comment">v2=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 20:16:58 CST 2021&#125;</span></span><br><span class="line"><span class="comment">v1=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri Jan 02 18:17:36 CST 1970&#125;</span></span><br><span class="line"><span class="comment">v2=&gt;Video&#123;name=&#x27;视频1&#x27;, createTime=Fri May 07 20:16:58 CST 2021&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>可以发现v1改变了，但是v2没改变，说明深克隆成功了</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/2021/05/07/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="工厂模式的定义与分类"><a href="#工厂模式的定义与分类" class="headerlink" title="工厂模式的定义与分类"></a>工厂模式的定义与分类</h1><p>定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。</p>
<p>分类：</p>
<ul>
<li>简单工厂模式<ul>
<li>用来生产同一等级结构中的任意产品(对于增加新的产品，需要覆盖已有代码)</li>
</ul>
</li>
<li>工厂方法模式<ul>
<li>用来生产同一等级结构中的固定产品(支持增加任意产品）</li>
</ul>
</li>
<li>抽象工厂模式<ul>
<li>围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</li>
</ul>
</li>
</ul>
<p>核心本质:</p>
<ul>
<li>实例化对象不使用new，用工厂方法代替</li>
<li>将选择实现类，创建对象统一管理和控制。从而将调用者跟我们的实现类解耦。</li>
</ul>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。</p>
<p>在简单工厂模式中创建实例的方法通常为静态（static）方法，因此简单工厂模式（Simple Factory Pattern）又叫作静态工厂方法模式（Static Factory Method Pattern）。</p>
<p>简单来说，简单工厂模式有一个具体的工厂类，可以生成多个不同的产品，属于创建型设计模式。简单工厂模式不在 GoF 23 种设计模式之列。</p>
<p>简单工厂模式每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度，违背了“开闭原则”。</p>
<h2 id="简单工厂模式优缺点"><a href="#简单工厂模式优缺点" class="headerlink" title="简单工厂模式优缺点"></a>简单工厂模式优缺点</h2><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。<strong>工厂和产品的职责区分明确。</strong></li>
<li>客户端无需知道所创建具体产品的类名，只需知道参数即可。</li>
<li>也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。且工厂类代码会非常臃肿，<strong>违背高聚合原则</strong>。</li>
<li>使用简单工厂模式会增加系统中类的个数（引入新的工厂类），<strong>增加系统的复杂度和理解难度</strong></li>
<li><strong>系统扩展困难</strong>，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂</li>
<li>简单工厂模式使用了 static 工厂方法，造成工厂角色<strong>无法形成基于继承的等级结构</strong>。</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。</p>
<h2 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>简单工厂模式的主要角色如下：</p>
<ul>
<li>简单工厂（SimpleFactory）：是简单工厂模式的核心，负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。</li>
<li>抽象产品（Product）：是简单工厂创建的所有对象的父类，负责描述所有实例共有的公共接口。</li>
<li>具体产品（ConcreteProduct）：是简单工厂模式的创建目标。</li>
</ul>
<p>实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用者  本来需要自己new  有了工厂后直接通过工厂获取相应的Car</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//WuLing car1 = new WuLing();</span></span><br><span class="line">        <span class="comment">//BenCi car2 = new BenCi();</span></span><br><span class="line">        Car car1 = CarFactory.getCar(<span class="string">&quot;五菱&quot;</span>);</span><br><span class="line">        Car car2 = CarFactory.getCar(<span class="string">&quot;奔驰&quot;</span>);</span><br><span class="line">        car1.name();</span><br><span class="line">        car2.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Car的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Car的具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenCi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奔驰!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Car的具体实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Car的简单工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (car.equals(<span class="string">&quot;五菱&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (car.equals(<span class="string">&quot;奔驰&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BenCi();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倘若现在需要添加一个新产品，就不得不修改原有代码，而工厂方法模式可以解决这个问题.</p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>简单工厂模式违背了开闭原则，而“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。</p>
<h2 id="工厂模式的优缺点"><a href="#工厂模式的优缺点" class="headerlink" title="工厂模式的优缺点"></a>工厂模式的优缺点</h2><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。</li>
<li>灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。</li>
<li>典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，满足迪米特法则、依赖倒置原则和里氏替换原则。</li>
</ul>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>类的个数容易过多，增加复杂度</li>
<li>增加了系统的抽象性和理解难度</li>
<li>抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。</li>
</ul>
<h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><ul>
<li>客户只知道创建产品的工厂名，而不知道具体的产品名。</li>
<li>创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。</li>
<li>客户不关心创建产品的细节，只关心产品的品牌</li>
</ul>
<h2 id="模式的结构与实现-1"><a href="#模式的结构与实现-1" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h2><p>工厂方法模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ol>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用时只需调用对应Car的工厂即可</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Car car1 = <span class="keyword">new</span> WuLingFactory().getCar();</span><br><span class="line">        Car car2 = <span class="keyword">new</span> BenCiFactory().getCar();</span><br><span class="line">        car1.name();</span><br><span class="line">        car2.name();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//若扩展一个新车也只需额外添加一个车类和相应的工厂类，没有在原有代码进行添加</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenCi</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;奔驰!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BenCiFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BenCi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//缺点明显了，每个Car类都会有一个对应的工厂类，代码量增多</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLing</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WuLingFactory</span> <span class="keyword">implements</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getCar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WuLing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">getCar</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2021/05/07/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="建造者模式的定义"><a href="#建造者模式的定义" class="headerlink" title="建造者模式的定义"></a>建造者模式的定义</h1><p>建造者模式也属于创建型模式，它提供了一种创建对象的最佳方式</p>
<p>定义:指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示,即产品的组成部分是不变的，但每一部分是可以灵活选择的</p>
<p>主要作用:在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。用户只需要给出指定复杂对象的类型和内容，建造者模式负责按顺序创建复杂对象(把内部的建造过程和细节隐藏起来)</p>
<h1 id="建造者模式的优缺点"><a href="#建造者模式的优缺点" class="headerlink" title="建造者模式的优缺点"></a>建造者模式的优缺点</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ol>
<li>封装性好，构建和表示分离。</li>
<li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li>
<li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h2><ol>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似;如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，如果产品内部发生变化，则建造者也要同步修改，后期维护成本较大。</li>
</ol>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性;</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
<li>适合于一个具有较多的零件（属性)的产品（对象）的创建过程。</li>
</ul>
<h2 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h2><ul>
<li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li>
<li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车!</li>
</ul>
<p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用</p>
<h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>建造者（Builder）模式的主要角色如下。</p>
<ol>
<li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个零部件。</li>
<li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li>
<li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li>
<li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li>
</ol>
<p>实现（造房子举例）:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品类，房子</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String buildA;</span><br><span class="line">    <span class="keyword">private</span> String buildB;</span><br><span class="line">    <span class="keyword">private</span> String buildC;</span><br><span class="line">    <span class="keyword">private</span> String buildD;</span><br><span class="line">    <span class="comment">//相应get、set方法以及toString方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildA</span><span class="params">()</span></span>;<span class="comment">//地基</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildB</span><span class="params">()</span></span>;<span class="comment">//钢筋工程</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildC</span><span class="params">()</span></span>;<span class="comment">//铺电线</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildD</span><span class="params">()</span></span>;<span class="comment">//粉刷</span></span><br><span class="line">    <span class="comment">//得到产品</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        product = <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildA(<span class="string">&quot;地基&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;地基&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildB(<span class="string">&quot;钢筋工程&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;钢筋工程&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildC(<span class="string">&quot;铺电线&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;铺电线&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildD</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setBuildD(<span class="string">&quot;粉刷&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;粉刷&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//导演类，相当于指挥，负责指挥一个工程的构建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        builder.buildA();</span><br><span class="line">        builder.buildB();</span><br><span class="line">        builder.buildC();<span class="comment">//这里可以控制房子的建造顺序</span></span><br><span class="line">        builder.buildD();</span><br><span class="line">        <span class="keyword">return</span> builder.getProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//指挥</span></span><br><span class="line">        Director director = <span class="keyword">new</span> Director();</span><br><span class="line">        Product build = director.build(<span class="keyword">new</span> Worker());</span><br><span class="line">        System.out.println(build.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    地基</span></span><br><span class="line"><span class="comment">    钢筋工程</span></span><br><span class="line"><span class="comment">    铺电线</span></span><br><span class="line"><span class="comment">    粉刷</span></span><br><span class="line"><span class="comment">    Product&#123;buildA=&#x27;地基&#x27;, buildB=&#x27;钢筋工程&#x27;, buildC=&#x27;铺电线&#x27;, buildD=&#x27;粉刷&#x27;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例是Builder模式的常规用法，导演类Director在 Builder模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把Director和抽象建造者进行结合。</p>
<p>通过静态内部类方式实现零件无序装配构造，这种方式使用更加灵活，更符合定义。内部有复杂对象的默认实现，使用时可以根据用户需求自由定义更改内容，并且无需改变具体的构造方式。就可以生产出不同复杂产品</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//产品类，KFC套餐</span></span><br><span class="line"><span class="comment">//get、set方法以及toString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String BuildA = <span class="string">&quot;汉堡&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String BuildB = <span class="string">&quot;可乐&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String BuildC = <span class="string">&quot;薯条&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> String BuildD = <span class="string">&quot;甜点&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildA</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildB</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildC</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Builder <span class="title">buildD</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> Product <span class="title">getProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实际的建造者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">()</span></span>&#123;</span><br><span class="line">        product = <span class="keyword">new</span> Product();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildA</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildA(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildB</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildB(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildC</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildC(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Builder <span class="title">buildD</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        product.setBuildD(msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//服务员</span></span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        <span class="comment">//链式编程，有默认内容(套餐)，用户也可以自定义组件(套餐内容)，</span></span><br><span class="line">        Product product = worker.buildA(<span class="string">&quot;全家桶&quot;</span>).buildB(<span class="string">&quot;雪碧&quot;</span>).getProduct();</span><br><span class="line">        <span class="comment">//Product&#123;BuildA=&#x27;全家桶&#x27;, BuildB=&#x27;雪碧&#x27;, BuildC=&#x27;薯条&#x27;, BuildD=&#x27;甜点&#x27;&#125;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Product product = worker.getProduct();</span></span><br><span class="line">        <span class="comment">//Product&#123;BuildA=&#x27;汉堡&#x27;, BuildB=&#x27;可乐&#x27;, BuildC=&#x27;薯条&#x27;, BuildD=&#x27;甜点&#x27;&#125;</span></span><br><span class="line">        System.out.println(product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>建造者模式</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/2021/05/15/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p><img src="/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/%E5%90%84%E6%8E%92%E5%BA%8F%E6%AF%94%E8%BE%83.png" alt="各种常用排序算法"></p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;<span class="comment">//插入的次数</span></span><br><span class="line">            <span class="keyword">int</span> insertNum = nums[i];<span class="comment">//要插入的数</span></span><br><span class="line">            <span class="keyword">int</span> count = i - <span class="number">1</span>;<span class="comment">//已经排序好的序列元素个数</span></span><br><span class="line">            <span class="comment">//序列从后到前循环，将大于insertNum的数向后移动一格</span></span><br><span class="line">            <span class="keyword">while</span>(count &gt;= <span class="number">0</span> &amp;&amp; nums[count] &gt; insertnum)&#123;</span><br><span class="line">                nums[count + <span class="number">1</span>] = nums[count];<span class="comment">//大于insertNum的数都后移</span></span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[count+<span class="number">1</span>] = insertNum;<span class="comment">//将需要插入的数放在要插入的位置。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShellSort</span> </span>&#123;</span><br><span class="line">    <span class="comment">//交换法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort1</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length,temp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//增量gap，并逐步缩小增量,确定循环次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = len/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>)&#123;</span><br><span class="line">             <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; len; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i -gap;j &gt;= <span class="number">0</span>;j -= gap)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(nums[j] &gt; nums[j+gap])&#123;</span><br><span class="line">                        <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                        temp = nums[j];</span><br><span class="line">                        nums[j] = nums[j+gap];</span><br><span class="line">                        nums[j+gap] = temp;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移位法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> gap = len/<span class="number">2</span>;gap &gt; <span class="number">0</span>; gap/=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = gap;i &lt; len;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> j = i,temp = nums[j];</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &lt; nums[j-gap])&#123;</span><br><span class="line">                    <span class="keyword">while</span>(j-gap &gt;= <span class="number">0</span> &amp;&amp; temp &lt; nums[j-gap])&#123;</span><br><span class="line">                        nums[j] = nums[j-gap];<span class="comment">//移动</span></span><br><span class="line">                        j -= gap;</span><br><span class="line">                    &#125;</span><br><span class="line">                    nums[j] = temp;<span class="comment">//当退出 while 后，就给 temp 找到插入的位置</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> min = nums[i];<span class="comment">//假设当前值为min，较小的值</span></span><br><span class="line">            <span class="keyword">int</span> pos = i;<span class="comment">//下标</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min &gt; nums[j])&#123;</span><br><span class="line">                    min = nums[j];<span class="comment">//记录当前较小的值</span></span><br><span class="line">                    pos = j;<span class="comment">//记录当前坐标</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(pos != i)&#123;</span><br><span class="line">                nums[pos] = nums[i];<span class="comment">//进行交换</span></span><br><span class="line">            	nums[i] = min;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。</span></span><br><span class="line"><span class="comment">//其中，N为数组下标索引值，如数组中第1个数对应的N为0。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapSort</span>  </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maxHeapDown</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="comment">//构造初始堆,从第一个非叶子节点开始调整,左右孩子节点中较大的交换到父节点中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len/<span class="number">2</span> -<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            headAdjust(nums,len,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序，将最大的节点放在堆尾，然后从根节点重新调整</span></span><br><span class="line">        <span class="keyword">for</span>(iny i = len -<span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">            nums[<span class="number">0</span>] = nums[i];</span><br><span class="line">            nums[i] = temp;</span><br><span class="line">            headAdjust(nums,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">headAdjust</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> len,<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">//k为当前判断的数下标，temp是父节点的值</span></span><br><span class="line">        <span class="keyword">int</span> k = i,temp = nums[i],index = <span class="number">2</span>*k +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; len)&#123;</span><br><span class="line">            <span class="comment">// 如果有右孩子，且右孩子大于左孩子的值，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(index+<span class="number">1</span> &lt; len &amp;&amp; nums[index] &lt; nums[index+<span class="number">1</span>])&#123;</span><br><span class="line">                    index++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//赋值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[index] &gt; temp)&#123;</span><br><span class="line">                nums[k] = nums[index];</span><br><span class="line">                k = index;</span><br><span class="line">                index = <span class="number">2</span> * k +<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">break</span>;<span class="comment">// 如果父节点大于任何一个孩子的值，则直接跳出</span></span><br><span class="line">        &#125;</span><br><span class="line">        nums[k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;<span class="comment">//排序次数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;len -i -<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;<span class="comment">//交换赋值</span></span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//优化版</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志位，是否进行交换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len -i -<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                    nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                    nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!flag) <span class="keyword">break</span>;<span class="comment">//未进行交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= right) <span class="keyword">return</span>;<span class="comment">//当两重合，说明左右都交换完毕</span></span><br><span class="line">         <span class="comment">//以temp为中间值</span></span><br><span class="line">        <span class="keyword">int</span> l = left, r = right,temp = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//小于temp的值都插入到temp左边</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] &gt;= temp) r--;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="comment">//大于temp的值都插入到temp右边</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= temp) l++;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = temp;<span class="comment">//将中间值插回</span></span><br><span class="line">        quickSort(nums,left,l -<span class="number">1</span>);<span class="comment">//递归排序</span></span><br><span class="line">        quickSort(nums,l + <span class="number">1</span>,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">	<span class="comment">//递归实现</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用递归的方式进行归并排序，所需要的空间复杂度是O（N+logN）</span></span><br><span class="line">        <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="comment">//递归地对左右两边进行排序</span></span><br><span class="line">            MergeSort(arr, low, mid);<span class="comment">//进行分组</span></span><br><span class="line">            MergeSort(arr, mid+<span class="number">1</span>, high);</span><br><span class="line">            merge(arr, low, mid, high);<span class="comment">//合并</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//merge函数实际上是将两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="comment">//因为数组有序，合并很简单，只要维护几个指针就可以了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//temp数组用于暂存合并的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//左半边的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="comment">//右半边的指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//合并后数组的指针</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将记录由小到大地放进temp数组</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= mid &amp;&amp; j &lt;= high; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[j])</span><br><span class="line">                temp[k] = arr[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[k] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        <span class="comment">//将temp数组中的元素写入到待排数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++)</span><br><span class="line">            arr[low + l] = temp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MergeSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergeSort2</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用非递归的方式来实现归并排序</span></span><br><span class="line">        <span class="keyword">int</span> len = arr.length;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt; len)&#123;</span><br><span class="line">            MergePass(arr, k, len);</span><br><span class="line">            k *= <span class="number">2</span>;         </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//MergePass方法负责将数组中的相邻的有k个元素的字序列进行归并</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MergePass</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">//从前往后,将2个长度为k的子序列合并为1个</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; n - <span class="number">2</span>*k + <span class="number">1</span>)&#123;</span><br><span class="line">            merge(arr, i, i + k-<span class="number">1</span>, i + <span class="number">2</span>*k - <span class="number">1</span>);</span><br><span class="line">            i += <span class="number">2</span>*k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这段代码保证了，将那些“落单的”长度不足两两merge的部分和前面merge起来。</span></span><br><span class="line">        <span class="keyword">if</span>(i &lt; n - k )&#123;</span><br><span class="line">            merge(arr, i, i+k-<span class="number">1</span>, n-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//merge函数实际上是将两个有序数组合并成一个有序数组</span></span><br><span class="line">    <span class="comment">//因为数组有序，合并很简单，只要维护几个指针就可以了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> low, <span class="keyword">int</span> mid, <span class="keyword">int</span> high)</span></span>&#123;</span><br><span class="line">        <span class="comment">//temp数组用于暂存合并的结果</span></span><br><span class="line">        <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[high - low + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//左半边的指针</span></span><br><span class="line">        <span class="keyword">int</span> i = low;</span><br><span class="line">        <span class="comment">//右半边的指针</span></span><br><span class="line">        <span class="keyword">int</span> j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//合并后数组的指针</span></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将记录由小到大地放进temp数组</span></span><br><span class="line">        <span class="keyword">for</span>(; i &lt;= mid &amp;&amp; j &lt;= high; k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] &lt; arr[j])</span><br><span class="line">                temp[k] = arr[i++];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                temp[k] = arr[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//接下来两个while循环是为了将剩余的（比另一边多出来的个数）放到temp数组中</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)</span><br><span class="line">            temp[k++] = arr[i++];</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= high)</span><br><span class="line">            temp[k++] = arr[j++];</span><br><span class="line">        <span class="comment">//将temp数组中的元素写入到待排数组中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; temp.length; l++)</span><br><span class="line">            arr[low + l] = temp[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RadixSort</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(<span class="keyword">int</span>[] array,<span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">1</span>;<span class="comment">//代表位数对应的数：1,10,100...</span></span><br><span class="line">        <span class="keyword">int</span> k=<span class="number">0</span>;<span class="comment">//保存每一位排序后的结果用于下一位的排序输入</span></span><br><span class="line">        <span class="keyword">int</span> length=array.length;</span><br><span class="line">        <span class="keyword">int</span>[][] bucket=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>][length];<span class="comment">//排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里</span></span><br><span class="line">        <span class="keyword">int</span>[] order=<span class="keyword">new</span> <span class="keyword">int</span>[length];<span class="comment">//用于保存每个桶里有多少个数字</span></span><br><span class="line">        <span class="keyword">while</span>(n&lt;d)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> num:array)&#123; <span class="comment">//将数组array里的每个数字放在相应的桶里</span></span><br><span class="line">                <span class="keyword">int</span> digit=(num/n)%<span class="number">10</span>;</span><br><span class="line">                bucket[digit][order[digit]]=num;</span><br><span class="line">                order[digit]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;<span class="comment">//将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果</span></span><br><span class="line">                <span class="keyword">if</span>(order[i]!=<span class="number">0</span>)&#123;<span class="comment">//这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;order[i];j++)&#123;</span><br><span class="line">                        array[k]=bucket[i][j];</span><br><span class="line">                        k++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                order[i]=<span class="number">0</span>;<span class="comment">//将桶里计数器置0，用于下一次位排序</span></span><br><span class="line">            &#125;</span><br><span class="line">            n*=<span class="number">10</span>;</span><br><span class="line">            k=<span class="number">0</span>;<span class="comment">//将k置0，用于下一轮保存位排序结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2021/05/07/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="抽象工厂模式的定义"><a href="#抽象工厂模式的定义" class="headerlink" title="抽象工厂模式的定义"></a>抽象工厂模式的定义</h1><p>抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<p>使用抽象工厂模式一般要满足以下条件。</p>
<ul>
<li>系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。</li>
<li>系统一次只可能消费其中某一族产品，即同族的产品一起使用。</li>
</ul>
<h1 id="抽象工厂模式的优缺点"><a href="#抽象工厂模式的优缺点" class="headerlink" title="抽象工厂模式的优缺点"></a>抽象工厂模式的优缺点</h1><p>抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下:</p>
<ul>
<li>可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理</li>
<li>当需要产品族时，抽象工厂可以保证客户端始终只使用同一个产品的产品族</li>
</ul>
<p>缺点：</p>
<ul>
<li>规定了所有可能被创建的产品集合,产品簇中扩展新的产品困难</li>
<li>增加了系统的抽象性和理解难度</li>
</ul>
<p>抽象工厂模式的扩展有一定的“开闭原则”倾斜性：</p>
<ol>
<li>当增加一个新的产品族时只需增加一个新的具体工厂，不需要修改原代码，满足开闭原则。</li>
<li>当产品族中需要增加一个新种类的产品时，则所有的工厂类都需要进行修改，不满足开闭原则。</li>
</ol>
<p>另一方面，当系统中只存在一个等级结构的产品时，抽象工厂模式将退化到工厂方法模式。</p>
<h1 id="抽象工厂模式的应用场景"><a href="#抽象工厂模式的应用场景" class="headerlink" title="抽象工厂模式的应用场景"></a>抽象工厂模式的应用场景</h1><p>抽象工厂模式最早的应用是用于创建属于不同操作系统的视窗构件。如Java的 AWT 中的 Button 和 Text 等构件在 Windows 和 UNIX 中的本地实现是不同的。</p>
<p>抽象工厂模式通常适用于以下场景：</p>
<ol>
<li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li>
<li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li>
<li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li>
</ol>
<h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>抽象工厂模式的主要角色如下。</p>
<ol>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li>
</ol>
<p>实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//手机产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IphoneProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为手机产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaPhone</span> <span class="keyword">implements</span> <span class="title">IphoneProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机开启&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为手机关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小米手机产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiPhone</span> <span class="keyword">implements</span> <span class="title">IphoneProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机开启&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米手机关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//路由器产品接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为路由器产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaRouter</span> <span class="keyword">implements</span> <span class="title">IRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器开启&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;华为路由器关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小米路由器产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiRouter</span> <span class="keyword">implements</span> <span class="title">IRouterProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器开启&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小米路由器关闭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂(总工厂)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生产手机</span></span><br><span class="line">    <span class="function">IphoneProduct <span class="title">iphoneProduct</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//生产路由器</span></span><br><span class="line">    <span class="function">IRouterProduct <span class="title">routerProduct</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//小米工厂，生成小米的所有产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MiFactory</span> <span class="keyword">implements</span> <span class="title">IProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IphoneProduct <span class="title">iphoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRouterProduct <span class="title">routerProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MiRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//华为工厂，生成华为的所有产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaFactory</span> <span class="keyword">implements</span> <span class="title">IProductFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IphoneProduct <span class="title">iphoneProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaPhone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRouterProduct <span class="title">routerProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaRouter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端，测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;==========小米产品==========&quot;</span>);</span><br><span class="line">        <span class="comment">//小米工厂</span></span><br><span class="line">        MiFactory miFactory = <span class="keyword">new</span> MiFactory();</span><br><span class="line">        IphoneProduct iphoneProduct = miFactory.iphoneProduct();</span><br><span class="line">        iphoneProduct.start();<span class="comment">//小米手机开启</span></span><br><span class="line">        iphoneProduct.shutdown();<span class="comment">//小米手机开启</span></span><br><span class="line">        IRouterProduct iRouterProduct = miFactory.routerProduct();</span><br><span class="line">        iRouterProduct.start();<span class="comment">//小米路由器开启</span></span><br><span class="line">        System.out.println(<span class="string">&quot;==========华为产品==========&quot;</span>);</span><br><span class="line">        <span class="comment">//华为工厂</span></span><br><span class="line">        HuaFactory huaFactory = <span class="keyword">new</span> HuaFactory();</span><br><span class="line">        IphoneProduct iphoneProduct1 = huaFactory.iphoneProduct();</span><br><span class="line">        iphoneProduct1.start();<span class="comment">//华为手机开启</span></span><br><span class="line">        iphoneProduct1.shutdown();<span class="comment">//华为手机关闭</span></span><br><span class="line">        IRouterProduct iRouterProduct1 = huaFactory.routerProduct();</span><br><span class="line">        iRouterProduct1.start();<span class="comment">//华为路由器开启</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>抽象工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表(散列)之哈希表</title>
    <url>/2021/05/10/%E6%95%B0%E7%AE%97%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><p>哈希表也称作散列表，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。</p>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-两数之和-力扣1"><a href="#1-两数之和-力扣1" class="headerlink" title="1.两数之和(力扣1)"></a>1.两数之和(力扣1)</h2><p><img src="/images/leetcode1.png" alt="力扣1"></p>
<p>思路：</p>
<p>暴力枚举，遍历数组，若数字中存在target - x 则返回,需要注意到每一个位于 <code>x</code> 之前的元素都已经和 <code>x</code> 匹配过，因此不需要再进行匹配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(j = i+<span class="number">1</span>;j &lt; len;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] == target)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i.j&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意到本题主要是查找target-x ，那么可以通过HashMap将每个值以及下标存进去，若map中存在target-x则返回各自的下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(temp))&#123;<span class="comment">//若mao中存在target-x 则返回各自下标</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i,map.get(temp)&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(nums[i],i);<span class="comment">//将数存入map中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-存在重复元素-力扣217"><a href="#2-存在重复元素-力扣217" class="headerlink" title="2.存在重复元素(力扣217)"></a>2.存在重复元素(力扣217)</h2><p><img src="/images/leetcode217.png" alt="力扣217"></p>
<p>思路:</p>
<p>暴力迭代，双重for循环判断，但是超出时间限制。</p>
<p>仔细理解题意，只要在数组中找到一个重复元素那么就返回true,可以使用hashSet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer,Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length;i++)&#123;<span class="comment">//也可以使用增强for循环</span></span><br><span class="line">            <span class="keyword">if</span>(!set.add(nums[i])) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还有一种解法，就是将数组进行排序，然后判断相邻的数是否相等，若相等则返回true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-最长和谐子序列-力扣594"><a href="#3-最长和谐子序列-力扣594" class="headerlink" title="3.最长和谐子序列(力扣594)"></a>3.最长和谐子序列(力扣594)</h2><p><img src="/images/leetcode594.png" alt="力扣594"></p>
<p>思路：</p>
<p>暴力迭代，使用双重for循环去统计每一个数以及这个数+1的个数，然后判断这个count哪个比较大即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, len = nums.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;<span class="comment">//标志数组中是否存在连续的两个数</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j] == nums[i]) count++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[j]+<span class="number">1</span> == nums[i])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若存在，则与res进行比较  例：nums = [1,1,1,1]  输出则为0</span></span><br><span class="line">            <span class="keyword">if</span>(flag) res = Math.max(count,res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的方法时间复杂度太高，耗时太久，可以使用HashMap统计每一个数和值+1的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;<span class="comment">//将每个数存入map中并统计每个数的个数</span></span><br><span class="line">            map.put(num,map.getOrDefault(num,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> key : map.keySet())&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(key+<span class="number">1</span>))<span class="comment">//统计key+1的个数</span></span><br><span class="line">                res = Math.max(res,map.get(key)+map.get(key+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-最长连续序列-力扣128"><a href="#4-最长连续序列-力扣128" class="headerlink" title="4.最长连续序列(力扣128)"></a>4.最长连续序列(力扣128)</h2><p><img src="/images/leetcode128.png" alt="力扣128"></p>
<p>思路:</p>
<p>将每个数存入HashSet中，记录set中存在的连续序列的长度，选出最长即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer,Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!set.contains(num-<span class="number">1</span>))&#123;<span class="comment">//如果成立，则说明该num的连续序列未被统计</span></span><br><span class="line">                <span class="keyword">int</span> curLength = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(set.contains(num-<span class="number">1</span>))&#123;</span><br><span class="line">                    curLength++;</span><br><span class="line">                    num++;<span class="comment">//值+1 </span></span><br><span class="line">                &#125;</span><br><span class="line">                maxLength = Math.amx(maxLength,curLength);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题判断数组连续序列的最大长度，那么排序后就可以很容易解题了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// max 最终结果, curr 当前长度, last 上个数字</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">1</span>, cur = <span class="number">1</span>, last = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == last) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == last+<span class="number">1</span>) cur++;<span class="comment">// 符合连续，长度 +1</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                max = Math.max(max,cur);<span class="comment">// 连不上了，记录长度</span></span><br><span class="line">                cur = <span class="number">1</span>;<span class="comment">// 重新开始</span></span><br><span class="line">            &#125;</span><br><span class="line">            last = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        max = Math.max(max,cur);<span class="comment">// 别忘了最后一段的连续区间</span></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title>数算之图</title>
    <url>/2021/05/12/%E6%95%B0%E7%AE%97%E4%B9%8B%E5%9B%BE/</url>
    <content><![CDATA[<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>定义：图(Graph)是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为: G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p>和线性表，树的差异:</p>
<ul>
<li>线性表中我们把数据元素叫元素，树中将数据元素叫结点，在图中数据元素，我们则称之为顶点(Vertex)。</li>
<li>线性表可以没有元素，称为空表；树中可以没有节点，称为空树；但是，在图中不允许没有顶点(有穷非空性)。</li>
<li>线性表中的各元素是线性关系，树中的各元素是层次关系，而图中各顶点的关系是用边来表示(边集可以为空)。</li>
</ul>
<blockquote>
<p>相关术语</p>
</blockquote>
<ul>
<li>顶点的度</li>
</ul>
<p>顶点Vi的度(Degree)是指在图中与Vi相关联的边的条数。对于有向图来说，有入度(In-degree)和出度(Out-degree)之分，有向图顶点的度等于该顶点的入度和出度之和。</p>
<ul>
<li>邻接</li>
</ul>
<p>若无向图中的两个顶点V1和V2存在一条边(V1,V2)，则称顶点V1和V2邻接(Adjacent)；</p>
<p>若有向图中存在一条边&lt;V3,V2&gt;，则称顶点V3与顶点V2邻接，且是V3邻接到V2或V2邻接直V3；</p>
<ul>
<li>路径</li>
</ul>
<p>在无向图中，若从顶点Vi出发有一组边可到达顶点Vj，则称顶点Vi到顶点Vj的顶点序列为从顶点Vi到顶点Vj的路径(Path)。</p>
<ul>
<li>连通</li>
</ul>
<p>若从Vi到Vj有路径可通，则称顶点Vi和顶点Vj是连通(Connected)的。</p>
<ul>
<li>权(Weight)</li>
</ul>
<p>有些图的边或弧具有与它相关的数字，这种与图的边或弧相关的数叫做权(Weight)。</p>
<blockquote>
<p>类型</p>
</blockquote>
<ol>
<li>无向图</li>
</ol>
<ul>
<li>如果图中任意两个顶点之间的边都是无向边(简而言之就是没有方向的边)，则称该图为无向图(Undirected graphs)。</li>
</ul>
<ol start="2">
<li>有向图</li>
</ol>
<ul>
<li>如果图中任意两个顶点之间的边都是有向边(简而言之就是有方向的边)，则称该图为有向图(Directed graphs)。</li>
</ul>
<ol start="3">
<li>完全图</li>
</ol>
<ul>
<li>无向完全图: 在无向图中，如果任意两个顶点之间都存在边，则称该图为无向完全图。(含有n个顶点的无向完全图有(n×(n-1))/2条边)</li>
<li>有向完全图: 在有向图中，如果任意两个顶点之间都存在方向互为相反的两条弧，则称该图为有向完全图。(含有n个顶点的有向完全图有n×(n-1)条边)</li>
</ul>
<blockquote>
<p>图的两种表示方式： </p>
</blockquote>
<ul>
<li>邻接矩阵表示法</li>
<li>邻接表表示法</li>
</ul>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-判断二分图-力扣785"><a href="#1-判断二分图-力扣785" class="headerlink" title="1.判断二分图(力扣785)"></a>1.判断二分图(力扣785)</h2><p><img src="/images/leetcode785.png" alt="力扣785"></p>
<p>思路：</p>
<p>首先要理解二分图的定义，就是顶点集V可分割为两个互不相交的子集，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个子集内的顶点不相邻。明白后我们可以使用图搜索算法从各个连通域的任一顶点开始遍历整个连通域，遍历的过程中用两种不同的颜色对顶点进行染色，相邻顶点染成相反的颜色。这个过程中倘若发现相邻的顶点被染成了相同的颜色，说明它不是二分图；反之，如果所有的连通域都染色成功，说明它是二分图</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="comment">//涂颜色使用的颜色，分别是：无色、红色和绿色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//用于记录节点颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line">    <span class="comment">//记录是否二分图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//图节点数量</span></span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//题中没有说明一定是连通图，所以需要每个没有涂色的节点作为起始节点涂颜色</span></span><br><span class="line">            <span class="keyword">if</span> (color[i] == UNCOLORED) &#123;</span><br><span class="line">                dfs(i, RED, graph);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> node, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        color[node] = c;</span><br><span class="line">        <span class="comment">//这次遍历中当前节点相邻节点应该涂的颜色</span></span><br><span class="line">        <span class="keyword">int</span> nc = c == RED ? GREEN : RED;</span><br><span class="line">        <span class="comment">//遍历当前节点相邻所有节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph[node]) &#123;</span><br><span class="line">            <span class="comment">//如果相邻接点还没涂色，则继续深度优先遍历涂色</span></span><br><span class="line">            <span class="keyword">if</span> (color[neighbor] == UNCOLORED) &#123;</span><br><span class="line">                dfs(neighbor, nc, graph);</span><br><span class="line">                <span class="comment">//判断上面遍历已经确定图不是二分图</span></span><br><span class="line">                <span class="keyword">if</span> (!valid) <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">//如果相邻节点已经有颜色，并且跟这次遍历本该涂的颜色不一致，说明不是二分图</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (color[neighbor] != nc) &#123;</span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNCOLORED = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RED = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> GREEN = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] color;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        color=  <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(color,UNCOLORED);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(color[i] == UNCOLORED)&#123;</span><br><span class="line">                Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                queue.offer(i);<span class="comment">//从此节点开始广搜</span></span><br><span class="line">                color[i] = RED;</span><br><span class="line">                <span class="keyword">while</span>(!queue.isEmpty)&#123;</span><br><span class="line">                    <span class="keyword">int</span> node = queue.poll();</span><br><span class="line">                    <span class="keyword">int</span> nc = color[node] == RED ? GREEN : RED;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> neighbor : graph[node])&#123;</span><br><span class="line">                        <span class="keyword">if</span>(color[neighbor] == UNCOLORED)&#123;<span class="comment">//防止死循环，没标记过的才进队列</span></span><br><span class="line">                            queue.offer(neighbor);</span><br><span class="line">                            color[neighbor] = nc;</span><br><span class="line">                            <span class="comment">//如果此节点已被标记过，看它的颜色和要染的颜色是否相同</span></span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(color[neighbor] != nc)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-课程表-力扣207"><a href="#2-课程表-力扣207" class="headerlink" title="2.课程表(力扣207)"></a>2.课程表(力扣207)</h2><p><img src="/images/leetcode207.png" alt="力扣207"></p>
<p>思路：</p>
<p>遍历图节点并标记是否被访问，借助一个标志列表flags，用于判断每个接待你 i (课程)的状态，对每一个节点进行dfs，判断是否有环，有直接返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites)</span> </span>&#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; adjacency = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//初始化邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            adjacency.add(<span class="keyword">new</span> ArrayList&lt;&gt;());<span class="comment">//添加numCourses个数组</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] flags = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//每个课程对应的flag</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] cp : prerequisites) &#123;<span class="comment">//把每个匹配单独取出来</span></span><br><span class="line">             <span class="comment">// cp[1]是前导课程，访问adj的第cp[1]个位置，然后添加cp[0]</span></span><br><span class="line">            adjacency.get(cp[<span class="number">1</span>].add(cp[<span class="number">0</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(adjacency,flags,i)) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//依次遍历adj每个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; adjacency,<span class="keyword">int</span>[] flags, <span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(flags[i] == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//本节点启动的 DFS 访问过了，一旦遇到了也说明有环</span></span><br><span class="line">        <span class="keyword">if</span>(flags[i] == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//其他节点启动的 DFS 访问过了，路径没问题，不需要再访问</span></span><br><span class="line">        flags[i] = <span class="number">1</span>;<span class="comment">//干净的，未被 DFS 访问</span></span><br><span class="line">        <span class="keyword">for</span>(Inyeger j : adjacency.get(i))&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dfs(adjacency,flags,j)) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//遍历i的每个邻居节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        flags[i] = -<span class="number">1</span>;<span class="comment">//完成该轮遍历时，flag置为-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-课程表-力扣210"><a href="#3-课程表-力扣210" class="headerlink" title="3.课程表(力扣210)"></a>3.课程表(力扣210)</h2><p><img src="/images/leetcode210.png" alt="力扣210"></p>
<p>思路：</p>
<p>建立邻接矩阵，DFS 访问每一个课程，若存在环直接返回，visited保存课程的访问状态，result数组保存课程的访问序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//深度优先遍历</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储有向图</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; edges;</span><br><span class="line">    <span class="comment">// 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成</span></span><br><span class="line">    <span class="keyword">int</span>[] visited;</span><br><span class="line">    <span class="comment">// 用数组来模拟栈，下标 n-1 为栈底，0 为栈顶</span></span><br><span class="line">    <span class="keyword">int</span>[] result;</span><br><span class="line">    <span class="comment">// 判断有向图中是否有环</span></span><br><span class="line">    <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 栈下标</span></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">        edges = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            edges.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        visited = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//初始化标记数组</span></span><br><span class="line">        result = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">//初始化结果数组</span></span><br><span class="line">        index = numCourses - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] info : prerequisites) &#123;</span><br><span class="line">            edges.get(info[<span class="number">1</span>]).add(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 每次挑选一个「未搜索」的节点，开始进行深度优先搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!valid) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 如果没有环，那么就有拓扑排序</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将节点标记为「搜索中」</span></span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 搜索其相邻节点</span></span><br><span class="line">        <span class="comment">// 只要发现有环，立刻停止搜索</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges.get(u)) &#123;</span><br><span class="line">            <span class="comment">// 如果「未搜索」那么搜索相邻节点</span></span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                dfs(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果「搜索中」说明找到了环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将节点标记为「已完成」</span></span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 将节点入栈</span></span><br><span class="line">        result[index--] = u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//广度优先遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] findOrder(<span class="keyword">int</span> numCourses, <span class="keyword">int</span>[][] prerequisites) &#123;</span><br><span class="line">    <span class="keyword">if</span> (numCourses == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];<span class="comment">// 建立入度表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123; <span class="comment">// 对于有先修课的课程，计算有几门先修课</span></span><br><span class="line">        inDegrees[p[<span class="number">0</span>]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入度为0的节点队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inDegrees.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) queue.offer(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 记录可以学完的课程数量</span></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[numCourses];  <span class="comment">// 可以学完的课程,结果数组</span></span><br><span class="line">    <span class="comment">// 根据提供的先修课列表，删除入度为 0 的节点</span></span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">int</span> curr = queue.poll();</span><br><span class="line">        res[count++] = curr;   <span class="comment">// 将可以学完的课程加入结果当中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] p : prerequisites) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p[<span class="number">1</span>] == curr)&#123;<span class="comment">//若先导课程为curr</span></span><br><span class="line">                inDegrees[p[<span class="number">0</span>]]--;<span class="comment">//入度-1</span></span><br><span class="line">                <span class="keyword">if</span> (inDegrees[p[<span class="number">0</span>]] == <span class="number">0</span>) queue.offer(p[<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == numCourses) <span class="keyword">return</span> res;<span class="comment">//判断学的课程总数与要学的课程总数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-冗余连接-力扣684"><a href="#4-冗余连接-力扣684" class="headerlink" title="4.冗余连接(力扣684)"></a>4.冗余连接(力扣684)</h2><p><img src="/images/leetcode684.png" alt="力扣684"></p>
<p>思路：</p>
<p>在一棵树中，边的数量比节点的数量少 1。如果一棵树有 N个节点，则这棵树有 N-1条边，存在冗余边该题边也是N，这条边导致树环的出现。可以通过并查集寻找冗余的边。初始时，每个节点都属于不同的连通分量，遍历每条边，判断边的两个顶点是否属于同一个连通分量</p>
<p>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</p>
<p>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为附加的边，将当前的边作为答案返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findRedundantConnection(<span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> count = edgs.length;</span><br><span class="line">        <span class="keyword">int</span>[] parent = <span class="keyword">new</span> <span class="keyword">int</span>[count+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) parent[i] = i;<span class="comment">//将父节点设为自己</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] edge : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> node1 = edge[<span class="number">0</span>], node2 = edge[<span class="number">1</span>];<span class="comment">//顶点1，顶点2</span></span><br><span class="line">            <span class="keyword">if</span>(find(parent,nodel) != find(parent,node2))&#123;<span class="comment">//两个顶点之间不连通</span></span><br><span class="line">                merge(parent,node1,node2);<span class="comment">//合并这两个顶点的连通分量</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> edge;<span class="comment">//直接返回冗余边</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//合并两个节点的连通分量</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] parent,<span class="keyword">int</span> index1,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">        parent[find(parent,index1)] = find(parent,index2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询该节点的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] parent,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent[index] != index)<span class="comment">//不等于自己</span></span><br><span class="line">            parent[index] = find(parent,parent[index]);</span><br><span class="line">        <span class="keyword">return</span> parent[index];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数算之字符串</title>
    <url>/2021/05/12/%E6%95%B0%E7%AE%97%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p> 字符串或串(String)是由数字、字母、下划线组成的一串字符。一般记为 s=“a1a2···an”(n&gt;=0)。它是编程语言中表示文本的数据类型。在程序设计中，字符串（string）为符号或数值的一个连续序列，如符号串（一串字符）或二进制数字串（一串二进制数字）。</p>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-有效的字母异位词-力扣242"><a href="#1-有效的字母异位词-力扣242" class="headerlink" title="1.有效的字母异位词(力扣242)"></a>1.有效的字母异位词(力扣242)</h2><p><img src="/images/leetcode242.png" alt="力扣242"></p>
<p>思路：</p>
<p>判断两个字符串是否是字母异位词有点类型化学的同分异构体，首先要判断两个字符串的长度，然后统计每个字符的个数，一一比较即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[] table = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//只有26个字母，用数组代替HashMap</span></span><br><span class="line">        <span class="keyword">for</span>(Char c : s.toCharArray())&#123;</span><br><span class="line">            table[c-<span class="string">&#x27;a&#x27;</span>]++;<span class="comment">//计算每个字母出现次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Chae c : t.toCharArray())&#123;</span><br><span class="line">            table[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            <span class="comment">//次数相减后，若小于零，则s字符串中不存在该字母</span></span><br><span class="line">            <span class="keyword">if</span>(table[c-<span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Char类型本质是数字，所以可以对s、t排序，然后一一比对，不相等则为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() != t.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr1 = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = t.toCharArray();</span><br><span class="line">        Arrays.sort(arr1);</span><br><span class="line">        Arrays.sort(arr2);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] != arr2[i]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-最长回文串-力扣409"><a href="#2-最长回文串-力扣409" class="headerlink" title="2.最长回文串(力扣409)"></a>2.最长回文串(力扣409)</h2><p><img src="/images/leetcode409.png" alt="力扣409"></p>
<p>思路：</p>
<p>主要判断字符串中偶数个字符和单个字符，偶数个字符必能成回文数，而单字符只能放在整个回文串的中间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] count = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];<span class="comment">//包含字母有大小之分</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            count[c]++;<span class="comment">//计算每个字符的次数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : count)&#123;</span><br><span class="line">            res += (i / <span class="number">2</span>) * <span class="number">2</span>;<span class="comment">//若有奇数个，相等于-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若长度相等，则说明都为偶数个，不相等则存在奇数字符，则+1</span></span><br><span class="line">        <span class="keyword">return</span> res == s.length() ? res + res+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-同构字符串-力扣205"><a href="#3-同构字符串-力扣205" class="headerlink" title="3.同构字符串(力扣205)"></a>3.同构字符串(力扣205)</h2><p><img src="/images/leetcode205.png" alt="力扣205"></p>
<p>思路：</p>
<p>判断同构字符串就是判断字符串中那些成对出现字符，若这些字符出现次数相等则为同构字符串,用HashMap映射字符出现的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character,Character&gt; sMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character,Character&gt; tMap = <span class="keyword">new</span> HashMao&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">char</span> sc = s.charAt(i), tc = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>((sMap.containsKey(sc) &amp;&amp; sMap.get(sc) != tc) || </span><br><span class="line">               tMap.contsinsKey(tc) &amp;&amp; tMap.get(tc) != sc)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sMap.put(sc,tc);</span><br><span class="line">            tMap.put(tx,sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用数组代替HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isIsomorphic</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] preIndexOfS = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span>[] preIndexOfT = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="comment">//按下标获取字符</span></span><br><span class="line">            <span class="keyword">char</span> sc = s.charAt(i), tc = t.charAt(i);</span><br><span class="line">            <span class="keyword">if</span>(preIndexOfS[sc] != preIndexOfT(tc)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            preIndexOfS[sc] = i+<span class="number">1</span>;<span class="comment">//数增加，简单理解就是出现的次数相同</span></span><br><span class="line">            preIndexOfT[tc] = i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-回文数-力扣9"><a href="#4-回文数-力扣9" class="headerlink" title="4.回文数(力扣9)"></a>4.回文数(力扣9)</h2><p><img src="/images/leetcode9.png" alt="力扣9"></p>
<p>思路：</p>
<p>可以将数字转化为字符串，将字符串反转为reversedStr，然后将reversedStr与原数字比较即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//简单粗暴，不宜采用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        String reversedStr = (<span class="keyword">new</span> StringBuilder(x + <span class="string">&quot;&quot;</span>)).reverse().toString();</span><br><span class="line">        <span class="keyword">return</span> (x + <span class="string">&quot;&quot;</span>).equals(reversedStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>去后半段数字进行反转与前半段进行比较，但是需要注意的是数字x的长度是奇数还是偶数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特殊情况，当 x &lt; 0 时，x 不是回文数。</span></span><br><span class="line">        <span class="comment">// 如果数字的最后一位是 0，为了使该数字为回文，</span></span><br><span class="line">        <span class="comment">// 则其第一位数字也应该是 0</span></span><br><span class="line">        <span class="comment">// 只有 0 满足这一属性</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> revertedNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; revertedNumber) &#123;</span><br><span class="line">            revertedNumber = revertedNumber * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当数字长度为奇数时，我们可以通过 revertedNumber/10 去除处于中位的数字。</span></span><br><span class="line">        <span class="comment">// 例如，当输入为 12321 时，在 while 循环的末尾我们可以得到 x = 12，revertedNumber = 123</span></span><br><span class="line">        <span class="comment">// 由于处于中位的数字不影响回文（它总是与自己相等），所以可以简单地将其去除。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-计数二进制子串-力扣696"><a href="#5-计数二进制子串-力扣696" class="headerlink" title="5.计数二进制子串(力扣696)"></a>5.计数二进制子串(力扣696)</h2><p><img src="/images/leetcode696.png" alt="力扣696"></p>
<p>思路：</p>
<p>题目计算的是包含相同次数的01的子串，重点是0或1都得是连续的不能分离，对于任意一个连续的0和1组成的子串，假设包含a个0和b个1，则该子串中符合条件的子串有min{a,b}个，例如00011，则符合条件的有01，0011</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBinarySubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> beforeCnt = <span class="number">0</span>; <span class="comment">//前一个数出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;<span class="comment">//当前数出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//统计符合题目的子串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(i-<span class="number">1</span>))&#123;<span class="comment">//当前字符是否和上一个相等</span></span><br><span class="line">                ++cnt;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                beforeCnt = cnt;</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(beforeCnt &gt;= cnt) res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-回文子串-力扣647"><a href="#6-回文子串-力扣647" class="headerlink" title="6.回文子串(力扣647)"></a>6.回文子串(力扣647)</h2><p><img src="/images/leetcode647.png" alt="力扣647"></p>
<p>思路：</p>
<p>计算一个字符串中存在多少个回文子串，那么需要遍历每一个字符，把每一个字符充当回文中心点，后用两个指针往两边扩展，若相等则为回文子串；但还需注意的是回文中心点既可以为1个字符还可以为2个字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length(), count = <span class="number">0</span>;<span class="comment">//子串个数</span></span><br><span class="line">        <span class="keyword">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;<span class="comment">//遍历每一个字符（中心点）</span></span><br><span class="line">            <span class="comment">// j == 0 表示 中心点为一个字符</span></span><br><span class="line">            <span class="comment">// j == 1 表示 中心点为两个字符</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> l = i, r = i + j;<span class="comment">//定义两个指针</span></span><br><span class="line">                <span class="keyword">while</span>((l &gt;= <span class="number">0</span> &amp;&amp; r &lt; len) &amp;&amp; cs[l] == cs[r])&#123;</span><br><span class="line">                    count++;</span><br><span class="line">                    l--;<span class="comment">//往左扩展</span></span><br><span class="line">                    r++;<span class="comment">//往右扩展</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划解法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">状态：dp[i][j] 表示字符串s在[i,j]区间的子串是否是一个回文串。</span><br><span class="line">状态转移方程：当 s[i] &#x3D;&#x3D; s[j] &amp;&amp; (j - i &lt; 2 || dp[i + 1][j - 1]) 时，dp[i][j]&#x3D;true，否则为false</span><br><span class="line">1.当只有一个字符时，比如 a 自然是一个回文串。</span><br><span class="line">2.当有两个字符时，如果是相等的，比如 aa，也是一个回文串。</span><br><span class="line">3.当有三个及以上字符时，比如 ababa 这个字符记作串 1，把两边的 a 去掉，也就是 bab 记作串 2，可以看出只要串2是一个回文串，那么左右各多了一个 a 的串 1 必定也是回文串。所以当 s[i]&#x3D;&#x3D;s[j] 时，自然要看 dp[i+1][j-1] 是不是一个回文串。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len][len];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; len; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= j; i++)&#123;</span><br><span class="line">                <span class="comment">//j - i &lt; 2  确保两个指针的中间只存在一个字符</span></span><br><span class="line">                <span class="comment">//dp[i+1][j-1] 两个指针中间的多字符也是回文子串</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">2</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表-数组和矩阵</title>
    <url>/2021/05/05/%E6%95%B0%E7%AE%97%E4%B9%8B%E6%95%B0%E7%BB%84%E4%B8%8E%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="数组与矩阵"><a href="#数组与矩阵" class="headerlink" title="数组与矩阵"></a>数组与矩阵</h1><blockquote>
<p>数组(Array)是有序的元素序列，一种连续存储的线性结构，元素类型相同；。</p>
<p>矩阵其实是二维的数组，其中元素是实数的矩阵称为实矩阵，元素是复数的矩阵称为复矩阵，而行数与列数都等于n的矩阵称为n阶矩阵或n阶方阵</p>
</blockquote>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-移动零-力扣283"><a href="#1-移动零-力扣283" class="headerlink" title="1.移动零(力扣283)"></a>1.移动零(力扣283)</h2><p><img src="/images/leetcode283.png" alt="力扣283"></p>
<p>思路：</p>
<p>题目要求是将所有0移到数组的末尾且顺序不变，其实也就是将非零元素在保持顺序不变的情况下移动到数组的前方，而后方则全部填0</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个数，标记要交换的下标</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//for循环扫描数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;	</span><br><span class="line">                <span class="keyword">if</span>(i &gt; index)&#123;</span><br><span class="line">                    nums[index] = nums[i];	<span class="comment">//将数交换</span></span><br><span class="line">                    nums[i] = <span class="number">0</span>;	<span class="comment">//将被交换的数设为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个数，记录非零数的个数</span></span><br><span class="line">        <span class="keyword">int</span> unZero = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//for循环扫描数组,将非零数移至前方</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                nums[unZero] = nums[i];</span><br><span class="line">                unZero++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数组后面的数填为0</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = unZero; i &lt; nums.length; i++)&#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-重塑矩阵-力扣566"><a href="#2-重塑矩阵-力扣566" class="headerlink" title="2.重塑矩阵(力扣566)"></a>2.重塑矩阵(力扣566)</h2><p><img src="/images/leetcode566.png" alt="力扣566"></p>
<p>思路：</p>
<p>该题可以理解为二维数组映射为一维数组，即 ( i , j ) -&gt; i X n + j   其中n为列数,然后通过一位数组映射成另一个r X c大小的数组</p>
<p>即 i = x / n; j = x % n;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] matrixReshape(<span class="keyword">int</span>[][] mat, <span class="keyword">int</span> r, <span class="keyword">int</span> c) &#123;</span><br><span class="line">        <span class="keyword">int</span> row = mat.length;</span><br><span class="line">        <span class="keyword">int</span> col = mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">if</span>(row*col != r*c) <span class="keyword">return</span> mat;</span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[][];<span class="comment">//新建数组保存结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++;)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; j++)&#123;</span><br><span class="line">                res[i][j] = mat[index/col][index%col];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-最大连续1的个数-力扣485"><a href="#3-最大连续1的个数-力扣485" class="headerlink" title="3.最大连续1的个数(力扣485)"></a>3.最大连续1的个数(力扣485)</h2><p><img src="/images/leetcode485.png" alt="力扣485"></p>
<p>思路：</p>
<p>计算最大连续1的个数，首先定义一个数用于保存1的连续个数，当碰到0时需要重新计算1的连续个数，将目前连续个数与结果保存(res)的个数进行比较，谁大返回谁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一  暴力匹配，若为1就计数 为0则重新计数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> cur = <span class="number">0</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            cur = nums[i] == <span class="number">1</span> ? cur+<span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            res = Math.max(res,cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法1中是暴力匹配，存在着重复匹配，我们在循环时其实已经知道1的连续数时，因此需要从下一个连续1开始计算，也是双指针解法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMaxConsecutiveOnes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.lenght, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;<span class="comment">//保存第一个1的起始下标</span></span><br><span class="line">            <span class="keyword">while</span>(j &lt; n &amp;&amp; nums[j] == <span class="number">1</span>) j++;</span><br><span class="line">            res = Math.max(res,j - i);</span><br><span class="line">            i = j;	<span class="comment">//从下一个1的坐标开始判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-错误的集合-力扣645"><a href="#4-错误的集合-力扣645" class="headerlink" title="4.错误的集合(力扣645)"></a>4.错误的集合(力扣645)</h2><p><img src="/images/leetcode645.png" alt="力扣645"></p>
<p>思路：</p>
<p>数组中包含1到n的整数，但存在两个重复的数，这两个数就是错误的数，首先将这个数保存，然后仔细看题不难发现丢失的数字与前一个数的差是二，而正确的连续两个数之差是为1的，知道这点后就可以解题了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> dup = -<span class="number">1</span>, missing = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                dup = nums[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>] + <span class="number">1</span>)</span><br><span class="line">                missing = nums[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;dup, nums[len - <span class="number">1</span>] != len ? len : missing&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于数组中正确的数本应出现一次，重复的数是错误的，基于这点可以用一个数组标记每个数的状态，即0未标记，1为标记，然后通过遍历该数组则得到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> res[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//开辟一个额外数组用来记录nums数组中每个数出现的次数</span></span><br><span class="line">        <span class="keyword">int</span> arr[] = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="comment">// 如果不为 0，则表示该数已经出现过，进行记录</span></span><br><span class="line">            <span class="keyword">if</span>(arr[num] != <span class="number">0</span>) res[<span class="number">0</span>] = num;</span><br><span class="line">            arr[num] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)&#123;</span><br><span class="line">            <span class="comment">// 如果为 0 则表示该数没有出现过，进行记录</span></span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-数组的度-力扣697"><a href="#5-数组的度-力扣697" class="headerlink" title="5.数组的度(力扣697)"></a>5.数组的度(力扣697)</h2><p><img src="/images/leetcode697.png" alt="力扣697"></p>
<p>思路:</p>
<p>该题的描述略微不清楚但是多阅读几遍题目后不难发现，该题是求数组中元素出现频率最大数且包含该元素的最短连续子数组的数组长度。拿示例二说明，示例二中2是出现最多的数，长度最短的数组则为2第一次出现的位置到2最后出现的位置的值，即为6</p>
<p>需要保存数组中不同元素出现的个数，所以要用到HashMap存储，然后定义两个数分别保存第一次出现的位置和最后一次出现的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findShortestSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length, maxCount = <span class="number">0</span>, minRes = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//键保存数组中元素的值，值为一个大小为2的数组</span></span><br><span class="line">        <span class="comment">//int[0]保存的是该元素第一次出现的下标,int[1]保存的是出现次数</span></span><br><span class="line">        Map&lt;Integer, <span class="keyword">int</span>[]&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span>[] pair = map.get(nums[i]);</span><br><span class="line">            <span class="comment">//为空第一次扫描，记录下标、出现次数+1</span></span><br><span class="line">            <span class="keyword">if</span> (pair == <span class="keyword">null</span>) &#123;</span><br><span class="line">                pair = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, <span class="number">1</span>&#125;;</span><br><span class="line">                map.put(nums[i], pair);<span class="comment">//将该数添加进map中</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pair[<span class="number">1</span>]++; <span class="comment">//次数+1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pair[<span class="number">1</span>] &gt; maxCount) &#123;<span class="comment">//如果这时出现次数大于之前的值，则保存该值</span></span><br><span class="line">                maxCount = pair[<span class="number">1</span>];</span><br><span class="line">                minRes = i - pair[<span class="number">0</span>] + <span class="number">1</span>;<span class="comment">//最小数组大小</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pair[<span class="number">1</span>] == maxCount) &#123;</span><br><span class="line">                minRes = Math.min(minRes, i - pair[<span class="number">0</span>] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minRes; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-托普利茨矩阵-力扣766"><a href="#6-托普利茨矩阵-力扣766" class="headerlink" title="6.托普利茨矩阵(力扣766)"></a>6.托普利茨矩阵(力扣766)</h2><p><img src="/images/leetcode766.png" alt="力扣766"></p>
<p>思路:</p>
<p>题目求的是对角线上的数字要相等，那么可以遍历格子来两两判断对角线上的值是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isToeplitzMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//这里m，n都减1防止下标越界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m-<span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n-<span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] != matrix[i+<span class="number">1</span>][j+<span class="number">1</span>]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-搜索二维矩阵-II-力扣240"><a href="#7-搜索二维矩阵-II-力扣240" class="headerlink" title="7.搜索二维矩阵 II(力扣240)"></a>7.搜索二维矩阵 II(力扣240)</h2><p><img src="/images/leetcode240.png" alt="力扣240"></p>
<p>思路：</p>
<p>搜索矩阵中的值，我们一开始最先想到的就是直接遍历，两个for循环直接判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] ints : matrix)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; matrix[<span class="number">0</span>].length; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ints[i] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 上面的解法是暴力解法，过程中没有使用到题目给的信息。题目告诉我们，每行的元素最大的在最右边，每列最大的在最下边。那么我们就需要修改起始遍历点，倘若还是放在1这个地方开始遍历很明显不合适，这时结合题目给的信息，我们可以将起始点设置在最右上这个点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length,  n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> row = <span class="number">0</span> , col = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(row &lt; col &amp;&amp; c &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//如果target找到，直接返回true</span></span><br><span class="line">            <span class="keyword">if</span>(target == matrix[row][col]) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//若遍历点的值大了，将遍历点往左移</span></span><br><span class="line">            <span class="keyword">if</span>(matrix[row][col] &gt; target) col--;</span><br><span class="line">            <span class="keyword">else</span> row++;<span class="comment">//否则往下移</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="8-有序矩阵中第-K-小的元素-力扣378"><a href="#8-有序矩阵中第-K-小的元素-力扣378" class="headerlink" title="8.有序矩阵中第 K 小的元素(力扣378)"></a>8.有序矩阵中第 K 小的元素(力扣378)</h2><p><img src="/images/leetcode378.png" alt="力扣378"></p>
<p>思路：</p>
<p>暴力遍历矩阵中的每一个数，定义一个数组将遍历的数都保存，而第k小的的数即数组下标为k-1的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.length, n = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[m*n];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">                arr[index] = matrix[i][j];</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="keyword">return</span> arr[k-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这种很明显不是最优解法，没有利用到题目给的信息。</p>
<ol>
<li>找出二维矩阵中最小的数 leftleft，最大的数 rightright，那么第 kk 小的数必定在 leftleft ~ rightright 之间</li>
<li>mid=(left+right) / 2mid=(left+right)/2；在二维矩阵中寻找小于等于 midmid 的元素个数 countcount</li>
<li>若这个 countcount 小于 kk，表明第 kk 小的数在右半部分且不包含 midmid，即 left=mid+1left=mid+1, right=rightright=right，又保证了第 kk 小的数在 leftleft ~ rightright 之间</li>
<li>若这个 countcount 大于 kk，表明第 kk 小的数在左半部分且可能包含 midmid，即 left=leftleft=left, right=midright=mid，又保证了第 kk 小的数在 left~rightleft right 之间</li>
<li>因为每次循环中都保证了第 kk 小的数在 leftleft ~ rightright 之间，当 left==rightleft==right 时，第 kk 小的数即被找出，等于 rightright</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> row = matrix.length;</span><br><span class="line">        <span class="keyword">int</span> col = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> right = matrix[row - <span class="number">1</span>][col - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="comment">// 每次循环都保证第K小的数在start~end之间，当start==end，第k小的数就是start</span></span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left)/ <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 找二维矩阵中&lt;=mid的元素总个数</span></span><br><span class="line">            <span class="keyword">int</span> count = findNotBiggerThanMid(matrix, mid, row, col);</span><br><span class="line">            <span class="keyword">if</span> (count &lt; k) &#123;</span><br><span class="line">                <span class="comment">// 第k小的数在右半部分，且不包含mid</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第k小的数在左半部分，可能包含mid</span></span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findNotBiggerThanMid</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> mid, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 以列为单位找，找到每一列最后一个&lt;=mid的数即知道每一列有多少个数&lt;=mid</span></span><br><span class="line">        <span class="keyword">int</span> i = row - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; col) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &lt;= mid) &#123;</span><br><span class="line">                <span class="comment">// 第j列有i+1个元素&lt;=mid</span></span><br><span class="line">                count += i + <span class="number">1</span>;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 第j列目前的数大于mid，需要继续在当前列往上找</span></span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="9-优美的排列-II-力扣667"><a href="#9-优美的排列-II-力扣667" class="headerlink" title="9.优美的排列 II(力扣667)"></a>9.优美的排列 II(力扣667)</h2><p><img src="/images/leetcode667.png" alt="力扣667"></p>
<p>思路:</p>
<p>重点在于产生k种差值。我们想要产生差值不同的，所以肯定是最大的减去最小的这样之后的操作才不会和这个操作重复。比如，1 2 3 4 5     如果k=3  那么我们第一步肯定是把5插入到1,2之间把最大差值算出(4 3 )，这样就完成了 4 3 1；如果k是4的话， 那么只需要移动当前的最后两位，1 5 2 3 4 -&gt; 1 5 2 4 3 ,剩下的数则按升序排列即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] constructArray(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">		<span class="comment">// 前 k 个数需要间隔从两端取；</span></span><br><span class="line">		<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; k) &#123; arr[i] = l; i++; l++; &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">if</span>(i &lt; k) &#123; arr[i] = r; i++; r--; &#125; <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 剩下的数字则按照降序或者升序排列；</span></span><br><span class="line">		<span class="keyword">if</span>(k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; arr.length; j++) &#123;</span><br><span class="line">				arr[j] = l;</span><br><span class="line">				l++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; arr.length; j++) &#123;</span><br><span class="line">				arr[j] = r;</span><br><span class="line">				r--;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="10-数组嵌套-力扣565"><a href="#10-数组嵌套-力扣565" class="headerlink" title="10.数组嵌套(力扣565)"></a>10.数组嵌套(力扣565)</h2><p><img src="/images/leetcode565.png" alt="力扣565"></p>
<p>思路：</p>
<p>求的是上一个数组的值是下一个数的下标，这样循环下去，返回最大的循环数组的个数，首先for循环遍历每一个数，若这个数有循环，则将该数置为-1，防止无限循环下去</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>; <span class="comment">//循环数组的最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = <span class="number">0</span>;<span class="comment">//当前循环的数组的个数</span></span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> t = nums[i];</span><br><span class="line">                nums[i] = -<span class="number">1</span>;<span class="comment">//将值设为1，防止无限循环</span></span><br><span class="line">                i = t;</span><br><span class="line">                temp++;</span><br><span class="line">            &#125;</span><br><span class="line">            max = Math.max(max,temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题还可以使用dfs解答：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">arrayNesting</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited =  <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];<span class="comment">//保存数组的数访问状态</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dfs(nums,visited,i,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">boolean</span>[] visited,<span class="keyword">int</span> index,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited[index])&#123;</span><br><span class="line">            maxCount = Math.max(maxCount,count);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> next = nums[index];</span><br><span class="line">        visited[index] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(nums,visited,next,count+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>数组与矩阵</tag>
      </tags>
  </entry>
  <entry>
    <title>树</title>
    <url>/2021/05/11/%E6%95%B0%E7%AE%97%E4%B9%8B%E6%A0%91/</url>
    <content><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>树是一种数据结构，它是n(n&gt;=0)个节点的有限集。n=0时称为空树。n&gt;0时，有限集的元素构成一个具有层次感的数据结构。</p>
<p>区别于线性表一对一的元素关系，树中的节点是一对多的关系。树具有以下特点:</p>
<ul>
<li>n&gt;0时，根节点是唯一的，不可能存在多个根节点。</li>
<li>每个节点有零个至多个子节点；除了根节点外，每个节点有且仅有一个父节点。根节点没有父节点</li>
</ul>
<blockquote>
<p>树的相关概念</p>
</blockquote>
<p><code>子树</code>: 除了根节点外，每个子节点都可以分为多个不相交的子树。(图二)</p>
<p><code>孩子与双亲</code>: 若一个结点有子树，那么该结点称为子树根的”双亲”，子树的根是该结点的”孩子”。在图一中，B、H是A的孩子，A是B、H的双亲。</p>
<p><code>兄弟</code>: 具有相同双亲的节点互为兄弟，例如B与H互为兄弟。</p>
<p><code>节点的度</code>: 一个节点拥有子树的数目。例如A的度为2，B的度为1，C的度为3.</p>
<p><code>叶子</code>: 没有子树，也即是度为0的节点。</p>
<p><code>分支节点</code>: 除了叶子节点之外的节点，也即是度不为0的节点。</p>
<p><code>内部节点</code>: 除了根节点之外的分支节点。</p>
<p><code>层次</code>: 根节点为第一层，其余节点的层次等于其双亲节点的层次加1.</p>
<p><code>树的高度</code>: 也称为树的深度，树中节点的最大层次。</p>
<p><code>有序树</code>: 树中节点各子树之间的次序是重要的，不可以随意交换位置。</p>
<p><code>无序树</code>: 树种节点各子树之间的次序是不重要的。可以随意交换位置。</p>
<p><code>森林</code>: 0或多棵互不相交的树的集合。例如图二中的两棵树为森林。</p>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-二叉树的最大深度-力扣104"><a href="#1-二叉树的最大深度-力扣104" class="headerlink" title="1.二叉树的最大深度(力扣104)"></a>1.二叉树的最大深度(力扣104)</h2><p><img src="/images/leetcode104.png" alt="力扣104"></p>
<p>思路：</p>
<p>二叉树的最大深度等于左右子树的最大深度+1；<br>左右子树的最大深度又等于其左右子树的最大深度+1，因此可用递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left),maxDepth(root.right))+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-二叉树的直径-力扣543"><a href="#2-二叉树的直径-力扣543" class="headerlink" title="2.二叉树的直径(力扣543)"></a>2.二叉树的直径(力扣543)</h2><p><img src="/images/leetcode543.png" alt="力扣543"></p>
<p>思路：</p>
<p>直径其实计算的是树的最长路径，具体来说是左子树的最大长度+右子树的最大长度+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;<span class="comment">//重复计算了，所以-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = dfs(root.left);<span class="comment">//左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> rightDepth = dfs(root.right);<span class="comment">//右子树的深度</span></span><br><span class="line">        ans = Math.max(ans,leftDepth+rightDepth+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.max(leftDepth,rightDepth)+<span class="number">1</span>;<span class="comment">//返回该节点为根的子树深度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-翻转二叉树-力扣226"><a href="#3-翻转二叉树-力扣226" class="headerlink" title="3.翻转二叉树(力扣226)"></a>3.翻转二叉树(力扣226)</h2><p><img src="/images/leetcode226.png" alt="力扣226"></p>
<p>思路：</p>
<p>从根节点开始，递归地对树进行遍历，并从叶子结点先开始翻转。如果当前遍历到的节点 root 的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root 为根节点的整棵子树的翻转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法一  先交换后递归</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode left = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法而  先递归再交换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode left = invertTree(root.left);</span><br><span class="line">        TreeNode right = invertTree(root.right);</span><br><span class="line">        <span class="comment">// 交换左右两个节点</span></span><br><span class="line">        root.left = right;</span><br><span class="line">        root.right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-合并二叉树-力扣617"><a href="#4-合并二叉树-力扣617" class="headerlink" title="4.合并二叉树(力扣617)"></a>4.合并二叉树(力扣617)</h2><p><img src="/images/leetcode617.png" alt="力扣617"></p>
<p>思路：</p>
<p>递归，同步遍历两颗树的节点，都不为空则相加建立新结点，如有一个树的节点为空则中止递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">mergeTrees</span><span class="params">(TreeNode root1, TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> root1 == <span class="keyword">null</span> ? root2 : root1;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(root1.val + root2.val);</span><br><span class="line">        node.left = mergeTrees(root1.left,root2.left);<span class="comment">//根节点的左子树</span></span><br><span class="line">        node.right = mergeTrees(root1.right,root2.right);<span class="comment">//根节点的右子树</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-对称二叉树-力扣101"><a href="#5-对称二叉树-力扣101" class="headerlink" title="5.对称二叉树(力扣101)"></a>5.对称二叉树(力扣101)</h2><p><img src="/images/leetcode101.png" alt="力扣101"></p>
<p>思路：</p>
<p>首先根节点无需判断，若为空则返回true；判断是否对称需要判断三点：左、右子树是否都为空，左子树为空右子树不为空或反之，左右节点的值是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root.left,root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> &amp;&amp; root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;	<span class="comment">//左、右子树是否都为空</span></span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="keyword">null</span> || root2 == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//有一个为null</span></span><br><span class="line">        <span class="keyword">if</span>(root1.val != root2.val) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//值不相等为false</span></span><br><span class="line">        <span class="keyword">return</span> isSymmetric(root1.left,root2.right) &amp;&amp; isSymmetric(root.right,root2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-路径总和-III-力扣437"><a href="#6-路径总和-III-力扣437" class="headerlink" title="6.路径总和 III(力扣437)"></a>6.路径总和 III(力扣437)</h2><p><img src="/images/leetcode437" alt="力扣437"></p>
<p>思路：</p>
<p>计算书中所有符合要求的路径，需要将每一个节点当作跟节点进行计算，怎么计算呢？将sum值减去当前节点的val值，如果为0则是一条路径，不为0则继续递归</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> targetSum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = countPath(root,targetSum);</span><br><span class="line">        <span class="keyword">int</span> a = countPath(root.left,targetSum);</span><br><span class="line">        <span class="keyword">int</span> b = countPath(root.right,targetSum);</span><br><span class="line">        <span class="keyword">return</span> res+a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">countPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        sum = sum - root.val;<span class="comment">//用于下次递归</span></span><br><span class="line">        <span class="keyword">int</span> res = sum == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;<span class="comment">//若为0，则路径+1</span></span><br><span class="line">        <span class="keyword">return</span> res + countPath(root.left,sum)+countPath(root.right,sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表之栈和队列</title>
    <url>/2021/05/11/%E6%95%B0%E7%AE%97%E4%B9%8B%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><p>栈（stack）：又名堆栈，它是一种运算受限的线性表。限定仅在表尾进行插入和删除操作的线性表。这一端被称为栈顶，相对地，把另一端称为栈底。向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素</p>
<p>队列：是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头.</p>
<blockquote>
<p>栈的常用方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>empty()</td>
<td>栈空返回true，否则返回false</td>
</tr>
<tr>
<td>peek()</td>
<td>获取栈顶值，不出栈</td>
</tr>
<tr>
<td>pop()</td>
<td>栈顶值出栈</td>
</tr>
<tr>
<td>push()</td>
<td>入栈</td>
</tr>
<tr>
<td>search(Object o)</td>
<td>返回对象o在栈中的位置(以1开始)</td>
</tr>
</tbody></table>
<blockquote>
<p>队列的方法</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>add()</td>
<td>入队(若失败则抛出异常)</td>
</tr>
<tr>
<td>offer()</td>
<td>将指定元素插入队列，成功返回true，否则返回false</td>
</tr>
<tr>
<td>element()</td>
<td>获取队头的值，但不出队(若队列为空则抛出异常)</td>
</tr>
<tr>
<td>peek()</td>
<td>获取队头的值，但不出队(若队列为空则返回null)</td>
</tr>
<tr>
<td>poll()</td>
<td>获取并移除队头(若队列空则返回null)</td>
</tr>
<tr>
<td>remove()</td>
<td>获取并移除队头(若队列空则抛出异常)</td>
</tr>
</tbody></table>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-用队列实现栈-力扣225"><a href="#1-用队列实现栈-力扣225" class="headerlink" title="1.用队列实现栈(力扣225)"></a>1.用队列实现栈(力扣225)</h2><p><img src="/images/leetcode225.png" alt="力扣225"></p>
<p>思路：</p>
<p>一个先进先出的数据结构，变为先进后出的。当压入一个元素的时候，pop()的时候能保证这个是第一个压入即可，所以之前队列里的那些数，重新弹出再压入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		queue = <span class="keyword">new</span> LinkedList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		queue.offer();</span><br><span class="line">        <span class="keyword">while</span>(queue.peek() != x)&#123;<span class="comment">//若栈顶不是x</span></span><br><span class="line">            queue.offer(queue.poll());<span class="comment">//则将x前面的数弹出重新压入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-用栈实现队列-力扣232"><a href="#2-用栈实现队列-力扣232" class="headerlink" title="2.用栈实现队列(力扣232)"></a>2.用栈实现队列(力扣232)</h2><p><img src="/images/leetcode232.png" alt="力扣232"></p>
<p>思路：</p>
<p>将一个栈当作输入栈，用于压入 push 传入的数据；另一个栈当作输出栈，用于 pop 和 peek操作。</p>
<p>每次 pop 或 peek 时，若输出栈为空则将输入栈的全部数据依次弹出并压入输出栈，这样输出栈从栈顶往栈底的顺序就是队列从队首往队尾的顺序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPush;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stackPop;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		stackPush = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stackPop = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">		stackPush.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> res = peek();<span class="comment">//获取弹出栈的栈顶元素</span></span><br><span class="line">        stackPop.pop();<span class="comment">//输出栈弹出一个数</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(stackPop.isEmpty())</span><br><span class="line">            <span class="keyword">while</span> (!stackPush.isEmpty())</span><br><span class="line">                stackPop.push(stackPush.pop());<span class="comment">//将输入栈的输弹出压入输出栈</span></span><br><span class="line">        <span class="keyword">return</span> stackPop.isEmpty() ? -<span class="number">1</span> : stackPop.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> stackPush.empty() &amp;&amp; stackPop.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-最小栈-力扣155"><a href="#3-最小栈-力扣155" class="headerlink" title="3.最小栈(力扣155)"></a>3.最小栈(力扣155)</h2><p><img src="/images/leetcode155.png" alt="力扣155"></p>
<p>思路：</p>
<p>定义两个栈，一个保存原本数据，另一个保存栈中的最小值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; data;<span class="comment">//数据栈</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helper;<span class="comment">//辅助栈</span></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		data = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        helper = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">		data.push(val);</span><br><span class="line">        <span class="comment">//两个栈都需加入值，保持数据数量的一致性</span></span><br><span class="line">        <span class="comment">//辅助栈中的栈顶存的是最小值</span></span><br><span class="line">        <span class="keyword">if</span>(helper.isEmpty || helper.peek() &gt;= x)&#123;</span><br><span class="line">            helper.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            helper.push(helper.peek());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两个栈都得 pop</span></span><br><span class="line">        helper.pop();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> helper.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-有效的括号-力扣20"><a href="#4-有效的括号-力扣20" class="headerlink" title="4.有效的括号(力扣20)"></a>4.有效的括号(力扣20)</h2><p><img src="/images.leetcode20.png" alt="力扣20"></p>
<p>思路：</p>
<p>解答本题要充分利用栈的先进后出这种特性，当我们遍历字符串的时候，若字符是’(‘，’[‘，’{‘中一种，那么直接在栈中压入与子对应的右括号；当遍历到不是左括号时直接弹栈与当前字符比较，若相等则继续遍历，直到栈为空，否则为false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//空串为true</span></span><br><span class="line">        <span class="keyword">if</span>(s.lenght % <span class="number">2</span> == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//长度为奇数一定不符合</span></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(Char c : s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;[&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">                stack.push(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(stack.isEmpty() || c != stack.pop())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-每日温度-力扣739"><a href="#5-每日温度-力扣739" class="headerlink" title="5.每日温度(力扣739)"></a>5.每日温度(力扣739)</h2><p><img src="/images/leetcode739.png" alt="力扣739"></p>
<p>思路：</p>
<p>题意是说几天后比今天温度高，若没有则为0，其实算的是这个数组的下标，可以双重for循环暴力解题，但是明显不好。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cur = T[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(T[j] &gt; cur)&#123;</span><br><span class="line">                    res[i] = j-i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>计算当前温度与后面的温度，那么没有与后面比较的温度值需要保存下来（下标压入栈），当找到了比自己大的温度后，将结果放入数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] dailyTemperatures(<span class="keyword">int</span>[] T) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = T.length;</span><br><span class="line">        <span class="keyword">int</span>[] anx = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = T[i];<span class="comment">//当前温度</span></span><br><span class="line">            <span class="comment">//若当前温度大于前一个温度，则弹栈</span></span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temp &gt; T[stack.peek])&#123;</span><br><span class="line">                <span class="keyword">int</span> preIndex = stack.pop();</span><br><span class="line">                <span class="comment">//将这两个温度的下标相减</span></span><br><span class="line">                ans[preIndex] = i - preIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);<span class="comment">//压入下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-下一个更大元素-II-力扣503"><a href="#6-下一个更大元素-II-力扣503" class="headerlink" title="6.下一个更大元素 II(力扣503)"></a>6.下一个更大元素 II(力扣503)</h2><p><img src="/images/leetcode503.png" alt="力扣503"></p>
<p>思路：</p>
<p><strong>于「找最近一个比当前值大/小」的问题，都可以使用单调栈来解决</strong>。单调栈就是在栈的基础上维护一个栈内元素单调。本题的单调栈中存入的都是前一个未被处理的下标，未处理的值与当前值进行比较，若当前值大，则修改res数组，还需注意的是题目给的是循环数组，所以循环时需要循环2*len-1次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] nextGreaterElements(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        Arrays.fill(res,-<span class="number">1</span>);<span class="comment">//将数组初始化，免去判断最大值</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">//循环数组，需循环2*len -1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len*<span class="number">2</span> -<span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; nums[stack.peek()] &lt; nums[i % len])&#123;</span><br><span class="line">                res[stack.pop()] = nums[i % len];<span class="comment">//对下标进行取模，防止越界</span></span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i % len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>线性表-链表</title>
    <url>/2021/05/09/%E6%95%B0%E7%AE%97%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域</p>
<p>n个节点离散分配，彼此通过指针相连，每个节点只有一个前驱节点，每个节点只有一个后续节点，首节点没有前驱节点，尾节点没有后续节点</p>
<h1 id="力扣实战"><a href="#力扣实战" class="headerlink" title="力扣实战"></a>力扣实战</h1><h2 id="1-相交链表-力扣160"><a href="#1-相交链表-力扣160" class="headerlink" title="1.相交链表(力扣160)"></a>1.相交链表(力扣160)</h2><p><img src="/images/leetcode160.png" alt="力扣160"></p>
<p>思路:</p>
<p>可以通过set集合来解决，将A链表的值存入set，后遍历B链表，若set集合中包含B链表中的值，则直接返回该值，没有则返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建集合set</span></span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">//先把链表A的结点全部存放到集合set中</span></span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">        set.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后访问链表B的结点，判断集合中是否包含链表B的结点，如果包含就直接返回</span></span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(headB))</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果集合set不包含链表B的任何一个结点，说明他们没有交点，直接返回null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路:</p>
<p>统计两个链表的长度，计算差值，谁长谁先走，走到长度相同后一起走，有相同值就返回，没相同值则返回null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//统计链表A和链表B的长度</span></span><br><span class="line">    <span class="keyword">int</span> lenA = length(headA), lenB = length(headB);</span><br><span class="line">    <span class="comment">//如果节点长度不一样，节点多的先走，直到他们的长度一样为止</span></span><br><span class="line">    <span class="keyword">while</span> (lenA != lenB) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lenA &gt; lenB) &#123;</span><br><span class="line">            <span class="comment">//如果链表A长，那么链表A先走</span></span><br><span class="line">            headA = headA.next;</span><br><span class="line">            lenA--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果链表B长，那么链表B先走</span></span><br><span class="line">            headB = headB.next;</span><br><span class="line">            lenB--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//然后开始比较，如果他俩不相等就一直往下走</span></span><br><span class="line">    <span class="keyword">while</span> (headA != headB) &#123;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//走到最后，最终会有两种可能，一种是headA为空，</span></span><br><span class="line">    <span class="comment">//也就是说他们俩不相交。还有一种可能就是headA</span></span><br><span class="line">    <span class="comment">//不为空，也就是说headA就是他们的交点</span></span><br><span class="line">    <span class="keyword">return</span> headA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//统计链表的长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node = node.next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>思路:</p>
<p>（双指针）设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</p>
<p>当指针访问完A节点后，去从B头节点开始访问；同样访问B也如此，这样A,B两个指针就能同时到达交点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode tempA = headA, tempB = headB;</span><br><span class="line">        <span class="keyword">while</span>(tempA != tempB)&#123;<span class="comment">//相交时退出</span></span><br><span class="line">            <span class="keyword">if</span>(tempA == <span class="keyword">null</span>)&#123;<span class="comment">//为空即遍历完，则开始遍历B</span></span><br><span class="line">                tempA = headB;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempA = tempA.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(tempB == <span class="keyword">null</span>)&#123;<span class="comment">//为空即遍历完，则开始遍历A</span></span><br><span class="line">                tempB = headA;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tempB = tempB.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tempA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-删除排序链表中的重复元素-力扣83"><a href="#2-删除排序链表中的重复元素-力扣83" class="headerlink" title="2.删除排序链表中的重复元素(力扣83)"></a>2.删除排序链表中的重复元素(力扣83)</h2><p><img src="/images/leetcode83.png" alt="力扣83"></p>
<p>思路：</p>
<p>链表已经排过序的，那么重复元素则是相邻元素，删除则就是将next指向下一个不同的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode node = head;</span><br><span class="line">        <span class="keyword">while</span>(node.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(node.val == node.next.val)&#123;</span><br><span class="line">                node.next = node.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                node = node.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归写法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">    head.next = deleteDuplicates(head.next);</span><br><span class="line">    <span class="keyword">return</span> head.val == head.next.val ? head.next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-反转链表-力扣206"><a href="#3-反转链表-力扣206" class="headerlink" title="3.反转链表(力扣206)"></a>3.反转链表(力扣206)</h2><p><img src="/images/leetcode206.png" alt="力扣206"></p>
<p>思路：</p>
<p>(迭代)反转链表其实不难，主要是将头节点的next置为null，而下一个节点的next指向上一个节点，尾节点也是如此，链表就反转完成了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode next = head.next;</span><br><span class="line">            head.next = pre;<span class="comment">//将头节点的next指向null</span></span><br><span class="line">            pre = head;<span class="comment">//将(辅助指针)前节点后移</span></span><br><span class="line">            head = next;<span class="comment">//头指针移至原链表的下一个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>(递归)链表反转，可以看成是头节点和剩余的子节点的反转，即原链表拆分成两个子链表，子链表的反转和原链表一样。可以这样理解，当原链表拆分成最后两个节点时，此时只剩head节点和尾节点，怎么反转呢？head.next.next = head即可，然后将head=null</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        ListNode newHead = reverseList(head.next);</span><br><span class="line">        head.next.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> newHead;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-回文链表-力扣234"><a href="#4-回文链表-力扣234" class="headerlink" title="4.回文链表(力扣234)"></a>4.回文链表(力扣234)</h2><p><img src="/images/leetcode234.png" alt="力扣234"></p>
<p>思路:</p>
<p>回文判断即判断前半部分是否会后半部分相等，可以想到栈后进先出，将链表存入栈中之后和原链表一一比较是否相等即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        ListNode tempNode = head;</span><br><span class="line">        <span class="keyword">while</span>(tempNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            stack.push(tempNode.val);</span><br><span class="line">            tempNode = tempNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(tempNode != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(tempNode.val != stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            tempNode = tempNode.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路:(进阶)</p>
<p>可以将链表拆两半，利用双指针前后比较值，相等即为回文链表</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="comment">//通过快慢指针找到中点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果fast不为空，说明链表的长度是奇数个</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="keyword">null</span>) slow = slow.next;</span><br><span class="line">    <span class="comment">//反转后半部分链表</span></span><br><span class="line">    slow = reverse(slow);</span><br><span class="line"></span><br><span class="line">    fast = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//然后比较，判断节点值是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (fast.val != slow.val)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode next = head.next;</span><br><span class="line">        head.next = prev;</span><br><span class="line">        prev = head;</span><br><span class="line">        head = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-两两交换链表中的节点-力扣24"><a href="#5-两两交换链表中的节点-力扣24" class="headerlink" title="5.两两交换链表中的节点(力扣24)"></a>5.两两交换链表中的节点(力扣24)</h2><p><img src="/images/leetcode24.png" alt="力扣24"></p>
<p>思路: (递归)</p>
<p>原链表可以拆分成三部分，头节点，第二节点，以及其他被处理好的节点。按照题目要求，将头节点指向其他节点，将第二节点指向第一节点即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//终止条件   只剩一个节点或为空</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//保存第二节点</span></span><br><span class="line">        ListNode nextNode = head.next;</span><br><span class="line">        <span class="comment">//第一个节点指向后面以及处理好的节点</span></span><br><span class="line">        head.next = swapPairs(nextNode.next);</span><br><span class="line">        <span class="comment">//第二个节点指向第一个节点</span></span><br><span class="line">        nextNode.next = head;</span><br><span class="line">        <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>思路：</p>
<p>添加一个额外节点，用于确定新的头节点，然后两两节点进行交换即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode node = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">    node.next = head;<span class="comment">//新建节点，指向头节点</span></span><br><span class="line">    ListNode pre = node;</span><br><span class="line">    <span class="keyword">while</span> (pre.next != <span class="keyword">null</span> &amp;&amp; pre.next.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//pre为-1   则-1-&gt;1-&gt;2-&gt;3-&gt;4    l1为1   l2为2</span></span><br><span class="line">        ListNode l1 = pre.next, l2 = pre.next.next;</span><br><span class="line">        ListNode next = l2.next;<span class="comment">//next节点为3</span></span><br><span class="line">        l1.next = next;<span class="comment">//将1节点指向3节点</span></span><br><span class="line">        l2.next = l1;<span class="comment">//将2节点指向1节点</span></span><br><span class="line">        pre.next = l2;<span class="comment">//将2置为头节点</span></span><br><span class="line"></span><br><span class="line">        pre = l1;<span class="comment">//1,2节点交互完，将pre节点置为1节点,即要处理的下俩个节点的前节点</span></span><br><span class="line">        <span class="comment">//即-1-&gt;2-&gt;1-&gt;3-&gt;4</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-两数相加-II-力扣445"><a href="#6-两数相加-II-力扣445" class="headerlink" title="6.两数相加 II(力扣445)"></a>6.两数相加 II(力扣445)</h2><p><img src="/images/leetcode445.png" alt="力扣445"></p>
<p>思路：</p>
<p>两个链表相加，最后一个数是个位数。那么相加时则是从末尾相加，自然而然想到栈，将两个链表的值依次加入栈中。相加时与进位一起相加，进位赋值为0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>) &#123;<span class="comment">//依次将值加入栈中</span></span><br><span class="line">            stack1.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;<span class="comment">//依次将值加入栈中</span></span><br><span class="line">            stack2.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        ListNode head = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//判断两个栈中是否还有数，以及是否存在进位</span></span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() || !stack2.isEmpty() || carry&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;<span class="comment">//将进位先加</span></span><br><span class="line">            sum += stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">            sum += stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">            ListNode node = <span class="keyword">new</span> ListNode(sum%<span class="number">10</span>);<span class="comment">//取模</span></span><br><span class="line">            node.next = head;</span><br><span class="line">            head = node;<span class="comment">//将head指针后移</span></span><br><span class="line">            carry  = sum/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-分隔链表-力扣725"><a href="#7-分隔链表-力扣725" class="headerlink" title="7.分隔链表(力扣725)"></a>7.分隔链表(力扣725)</h2><p><img src="/images/leetcode725.png" alt="力扣725"></p>
<p>思路：</p>
<p>将链表分割成k个小链表为一个数组，每个链表的大小之差不能大于1。首先将链表除于k算出每个小链表的平均数，然后算还剩多少个数，然后平均分配。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> LiskNode[k];</span><br><span class="line">        ListNode cur = root;</span><br><span class="line">        ListNode[] listNodes = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;<span class="comment">//计算原链表的长度</span></span><br><span class="line">        <span class="keyword">while</span>(root != <span class="keyword">null</span>)&#123;</span><br><span class="line">            len++;</span><br><span class="line">            root = root.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> width = len / k;<span class="comment">//链表的平均长度</span></span><br><span class="line">        <span class="keyword">int</span> num = len % k;	<span class="comment">//剩多少个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;	<span class="comment">//创建k个小链表</span></span><br><span class="line">            ListNode head = <span class="keyword">new</span> ListNode(<span class="number">0</span>), temp = head;</span><br><span class="line">            <span class="comment">//运用一个三元运算符 若num还有数则将其分配个小链表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;width + (i &lt; num ? i :<span class="number">0</span>); j++)&#123;</span><br><span class="line">                temp = temp.next = <span class="keyword">new</span> ListNode(cur.val);</span><br><span class="line">                <span class="comment">//将cur指针也往后移，遍历原链表的值</span></span><br><span class="line">                <span class="keyword">if</span>(cur != <span class="keyword">null</span>) cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            listNodes[i] = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> listNodes;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是新建链表，在已知各个小链表的大小情况下，我们可以将原链表拆分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode[] splitListToParts(ListNode root, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        ListNode temp = root;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(temp!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            temp = temp.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个部分存放几个节点</span></span><br><span class="line">        <span class="keyword">int</span> part = len&lt;k ? <span class="number">1</span> : len/k;</span><br><span class="line">        <span class="comment">//有几个多一个节点的部分</span></span><br><span class="line">        <span class="keyword">int</span> many = len&lt;k ? <span class="number">0</span> : len%k;</span><br><span class="line">        ListNode[] res = <span class="keyword">new</span> ListNode[k];</span><br><span class="line">        temp = root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">            <span class="comment">//保存头节点</span></span><br><span class="line">            res[i] = temp;</span><br><span class="line">            <span class="comment">//指针挪动到该部分的最后一个节点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; part-<span class="number">1</span>+(i&lt;many?<span class="number">1</span>:<span class="number">0</span>)&amp;&amp; temp!=<span class="keyword">null</span>;j++)&#123;</span><br><span class="line">                temp = temp.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(temp==<span class="keyword">null</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//断开前保存下一个节点</span></span><br><span class="line">            ListNode next = temp.next;</span><br><span class="line">            <span class="comment">//部分之间要断开链表</span></span><br><span class="line">            temp.next = <span class="keyword">null</span>;</span><br><span class="line">            temp = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2021/05/08/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="桥接模式的定义"><a href="#桥接模式的定义" class="headerlink" title="桥接模式的定义"></a>桥接模式的定义</h1><p>定义：将抽象与实现分离，使它们可以独立变化。</p>
<p>它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>桥接模式偶尔类似于多继承方案，但是多继承方案违背了类的单一职责原则，复用性比较差，类的个数也非常多，桥接模式是比多继承方案更好的解决方法。</p>
<p>实际场景：</p>
<p>Java语言通过JVM实现平台无关性(程序、系统)、AWT中的Peer架构、JDBC驱动程序</p>
<h1 id="桥接模式的优缺点"><a href="#桥接模式的优缺点" class="headerlink" title="桥接模式的优缺点"></a>桥接模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ol>
<li>抽象与实现分离，扩展能力强</li>
<li>符合开闭原则</li>
<li>符合合成复用原则，极大的减少了子类的个数，从而降低管理和维护的成本</li>
<li>其实现细节对客户透明</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ol>
<li>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计</li>
<li>模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</li>
</ol>
<h1 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h1><p>当一个类内部具备两种或多种变化维度时，使用桥接模式可以解耦这些变化的维度，使高层代码架构稳定。</p>
<p>桥接模式通常适用于以下场景。</p>
<ol>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。</li>
</ol>
<p>桥接模式的一个常见使用场景就是替换继承。我们知道，继承拥有很多优点，比如，抽象、封装、多态等，父类封装共性，子类实现特性。继承可以很好的实现代码复用（封装）的功能，但这也是继承的一大缺点。</p>
<p>因为父类拥有的方法，子类也会继承得到，无论子类需不需要，这说明继承具备强侵入性（父类代码侵入子类），同时会导致子类臃肿。因此，在设计模式中，有一个原则为优先使用组合/聚合，而不是继承。</p>
<h1 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h1><p>桥接（Bridge）模式包含以下主要角色。</p>
<ol>
<li>抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。</li>
</ol>
<p>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不同品牌的电脑的不同款式</span></span><br><span class="line"><span class="comment">//品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//联想品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;联想&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//苹果品牌</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;苹果&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//电脑类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//组合的方式，加入品牌</span></span><br><span class="line">    <span class="keyword">protected</span> Brand brand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Computer</span><span class="params">(Brand brand)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">        brand.info();<span class="comment">//自带品牌</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//台式款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desktop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">&quot;台式机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//笔记本款</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">extends</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.info();</span><br><span class="line">        System.out.println(<span class="string">&quot;笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//需要苹果笔记本</span></span><br><span class="line">        Laptop computer = <span class="keyword">new</span> Laptop(<span class="keyword">new</span> Apple());</span><br><span class="line">        computer.info();<span class="comment">//苹果笔记本</span></span><br><span class="line">        <span class="comment">//需要联想台式机</span></span><br><span class="line">        Desktop computer2 = <span class="keyword">new</span> Desktop(<span class="keyword">new</span> Lenovo());</span><br><span class="line">        computer2.info();<span class="comment">//联想台式机</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式模式的扩展"><a href="#桥接模式模式的扩展" class="headerlink" title="桥接模式模式的扩展"></a>桥接模式模式的扩展</h2><p>在软件开发中，有时桥接（Bridge）模式可与适配器模式联合使用。当桥接（Bridge）模式的实现化角色的接口与现有类的接口不一致时，可以在二者中间定义一个适配器将二者连接起来。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>桥接模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式概述</title>
    <url>/2021/05/07/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<h1 id="设计模式—前言"><a href="#设计模式—前言" class="headerlink" title="设计模式—前言"></a>设计模式—前言</h1><p><code>设计模式是前辈对代码开发经验的总结，是解决问题的一系列套路。它不是语法规定，而是一套用来提高代码可复用性、可维护性、可读性、稳健性以及安全性的解决方案。1995年，GOF合作出版《设计模式：可复用面向对象软件的基础》一书，共收录23种设计模式，从此树立了软件设计模式领域的里程碑，人称「GoF设计模式」。这 23 种设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性，以及类的关联关系和组合关系的充分理解</code></p>
<h1 id="学习设计模式的意义"><a href="#学习设计模式的意义" class="headerlink" title="学习设计模式的意义"></a>学习设计模式的意义</h1><ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<p>当然，软件设计模式只是一个引导。在具体的软件幵发中，必须根据设计的应用系统的特点和要求来恰当选择。对于简单的程序开发，苛能写一个简单的算法要比引入某种设计模式更加容易。但对大项目的开发或者框架设计，用设计模式来组织代码显然更好。</p>
<h1 id="软件设计模式的基本要素"><a href="#软件设计模式的基本要素" class="headerlink" title="软件设计模式的基本要素"></a>软件设计模式的基本要素</h1><p>软件设计模式使人们可以更加简单方便地复用成功的设计和体系结构，它通常包含以下几个基本要素：模式名称、别名、动机、问题、解决方案、效果、结构、模式角色、合作关系、实现方法、适用性、已知应用、例程、模式扩展和相关模式等，其中最关键的元素包括以下 4 个主要部分。</p>
<h2 id="1-模式名称"><a href="#1-模式名称" class="headerlink" title="1. 模式名称"></a>1. 模式名称</h2><p>每一个模式都有自己的名字，通常用一两个词来描述，可以根据模式的问题、特点、解决方案、功能和效果来命名。模式名称（PatternName）有助于我们理解和记忆该模式，也方便我们来讨论自己的设计。</p>
<h2 id="2-问题"><a href="#2-问题" class="headerlink" title="2. 问题"></a>2. 问题</h2><p>问题（Problem）描述了该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件。</p>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><p>模式问题的解决方案（Solution）包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式。因为模式就像一个模板，可应用于多种不同场合，所以解决方案并不描述一个特定而具体的设计或实现，而是提供设计问题的抽象描述和怎样用一个具有一般意义的元素组合（类或对象的 组合）来解决这个问题。</p>
<h2 id="4-效果"><a href="#4-效果" class="headerlink" title="4. 效果"></a>4. 效果</h2><p>描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题。显式地列出这些效果（Consequence）对理解和评价这些模式有很大的帮助。</p>
<h1 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h1><ul>
<li>创建型模式<ul>
<li>单例模式、工厂模式、抽象工厂模式、建造者模式、原型模式</li>
</ul>
</li>
<li>结构型模式<ul>
<li>适配器模式、桥接模式、装饰器模式、组合模式、外观模式、享元模式、代理模式</li>
</ul>
</li>
<li>行为型模式<ul>
<li>模板方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式、访问者模式</li>
</ul>
</li>
</ul>
<h1 id="GoF的23种设计模式的功能"><a href="#GoF的23种设计模式的功能" class="headerlink" title="GoF的23种设计模式的功能"></a>GoF的23种设计模式的功能</h1><ol>
<li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li>
<li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li>
<li>工厂方法（Factory Method）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li>
<li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li>
<li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li>
<li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li>
<li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li>
<li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</li>
<li>装饰（Decorator）模式：动态的给对象增加一些职责，即增加其额外的功能。</li>
<li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li>
<li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li>
<li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li>
<li>模板方法（TemplateMethod）模式：定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</li>
<li>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</li>
<li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li>
<li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li>
<li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li>
<li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li>
<li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li>
<li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li>
<li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li>
<li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li>
<li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li>
</ol>
<h1 id="OOP七大原则"><a href="#OOP七大原则" class="headerlink" title="OOP七大原则"></a>OOP七大原则</h1><ul>
<li>开闭原则： 对扩展开发，对修改关闭</li>
<li>里氏替换原则： 继承必须确保超类所拥有的性质在子类中仍然成立</li>
<li>依赖倒置原则： 要面向接口编程，不要面向实现bianc</li>
<li>单一职责原则： 控制类的粒度大小、将对象解耦、提高其内聚性</li>
<li>接口隔离原则： 要为各个类建立它们需要的专用接口</li>
<li>迪米特法则： 一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话</li>
<li>合成复用原则： 尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系实现</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2021/05/07/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="适配器模式的定义"><a href="#适配器模式的定义" class="headerlink" title="适配器模式的定义"></a>适配器模式的定义</h1><p>定义：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<p>常见的应用：InputStreamReader(InputStream)、SpringMVC中adapterServlet等</p>
<h1 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h2><ul>
<li>客户端通过适配器可以透明地调用目标接口。</li>
<li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配</li>
<li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li>
<li>在很多业务场景中符合开闭原则。</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h2><ul>
<li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
<li>对于Java、C#等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者;</li>
<li>在Java、C#等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li>
</ul>
<h1 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h1><p>适配器模式（Adapter）通常适用于以下场景。</p>
<ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h1 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h1><p>适配器模式（Adapter）包含以下主要角色。</p>
<ol>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//要被适配的类  (网线)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接网线上网&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//适配器   接口转换器的抽象实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetToUSB</span> </span>&#123;</span><br><span class="line">    <span class="comment">//处理请求，网线连接USB</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//真正的适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptation</span> <span class="keyword">implements</span> <span class="title">NetToUSB</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用父类方法</span></span><br><span class="line">        <span class="keyword">super</span>.request();<span class="comment">//可以上网了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//想上网，但无法连上网线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">(NetToUSB adapter)</span></span>&#123;</span><br><span class="line">        <span class="comment">//上网的具体实现  需要一个转接头</span></span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//测试</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//电脑 &lt;-&gt; 适配器 &lt;-&gt; 网线</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        <span class="comment">//该adaptation未被使用，原因在于Computer类中已经连上网线了</span></span><br><span class="line">        Adaptation adaptation = <span class="keyword">new</span> Adaptation();</span><br><span class="line">        Adapter adapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        computer.net(adapter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时的适配器模式还存在一个问题，即java中是单继承的有局限性（类适配器）,我们在开发中常用的是对象适配器，是一种组合的方式实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//新建一个适配器类</span></span><br><span class="line"><span class="comment">//组合实现的对象适配器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter2</span> <span class="keyword">implements</span> <span class="title">NetToUSB</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptation adaptation;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter2</span><span class="params">(Adaptation adaptation)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptation = adaptation;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptation.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//想上网，但无法连上网线</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">net</span><span class="params">(NetToUSB adapter)</span></span>&#123;</span><br><span class="line">        <span class="comment">//上网的具体实现  需要一个转接头</span></span><br><span class="line">        adapter.handleRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//电脑 &lt;-&gt; 适配器 &lt;-&gt; 网线</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer();</span><br><span class="line">        Adaptation adaptation = <span class="keyword">new</span> Adaptation();</span><br><span class="line">        <span class="comment">//传入adaptation</span></span><br><span class="line">        Adapter2 adapter2 = <span class="keyword">new</span> Adapter2(adaptation);</span><br><span class="line">        computer.net(adapter2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>适配器模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数算之题型总结</title>
    <url>/2021/05/13/%E6%95%B0%E7%AE%97%E4%B9%8B%E9%A2%98%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h1><ul>
<li>双指针</li>
<li>二分查找</li>
<li>排序</li>
<li>分治</li>
<li>搜索</li>
<li>动态规划</li>
<li>数学</li>
</ul>
<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="1-两数之和-II-输入有序数组-力扣167"><a href="#1-两数之和-II-输入有序数组-力扣167" class="headerlink" title="1.两数之和 II - 输入有序数组(力扣167)"></a>1.两数之和 II - 输入有序数组(力扣167)</h2><p><img src="/images/leetcode.png" alt="力扣167"></p>
<p>思路：</p>
<p>数组升序排列的，使用双指针，一个指针指向值最小的元素，一个指针指向值最大的元素。指向最小元素的指针从头向尾遍历，指向最大元素的指针从尾向头遍历。</p>
<p>如果两个指针指向元素的和 sum == target，那么得到要求的结果；<br>如果 sum &gt; target，移动较大的元素，使 sum 变小一些；<br>如果 sum &lt; target，移动较小的元素，使 sum变大一些；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = numbers.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = len -<span class="number">1</span>; i &lt; j;)&#123;<span class="comment">//双指针，一个最右，一个最左</span></span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span>(sum == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,j+<span class="number">1</span>&#125;;<span class="comment">//下标从1计数，要+1</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) j--;</span><br><span class="line">            <span class="keyword">else</span> i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找：在数组中找到两个数，使得它们的和等于目标值，可以首先固定第一个数，然后寻找第二个数，第二个数等于目标值减去第一个数的差。利用数组的有序性质，可以通过二分查找的方法寻找第二个数。为了避免重复寻找，在寻找第二个数时，只在第一个数的右侧寻找</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> len  = numbers.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> low = <span class="number">0</span>, high = len-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (high - low) / <span class="number">2</span> + low;<span class="comment">//从中间取值</span></span><br><span class="line">                <span class="keyword">if</span>(numbers[mid] == target - nums[i])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i+<span class="number">1</span>,mid+<span class="number">1</span>&#125;;<span class="comment">//下标从1计数，要+1</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(numbers[mid] &gt; target - nums[i])&#123;</span><br><span class="line">                    high = mid - <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    low = mid + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-反转字符串中的元音字符-力扣345"><a href="#2-反转字符串中的元音字符-力扣345" class="headerlink" title="2.反转字符串中的元音字符(力扣345)"></a>2.反转字符串中的元音字符(力扣345)</h2><p><img src="/images/leetcode345.png" alt="力扣345"></p>
<p>思路：</p>
<p>将字符串中元音字母进行交，利用两个指针一个指头一个指尾，若两个指针都指向了元音字母则进行交换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> , j = s.length -<span class="number">1</span>; i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!isVowel(chars[i]))&#123;<span class="comment">//将指针移至元音字母上</span></span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!isVowel(chars[j]))&#123;</span><br><span class="line">                j--;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">            chars[i] = chars[j];</span><br><span class="line">            chars[j] = temp;</span><br><span class="line">            i++;<span class="comment">//避免死循环</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(chars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isVowel</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;<span class="comment">//判断是不是元音字母，注意大小写</span></span><br><span class="line">        <span class="keyword">return</span> (c==<span class="string">&#x27;a&#x27;</span> || c==<span class="string">&#x27;e&#x27;</span> || c==<span class="string">&#x27;i&#x27;</span> || c==<span class="string">&#x27;o&#x27;</span> || c == <span class="string">&#x27;u&#x27;</span></span><br><span class="line">                || c==<span class="string">&#x27;A&#x27;</span> || c==<span class="string">&#x27;E&#x27;</span> || c==<span class="string">&#x27;I&#x27;</span> || c==<span class="string">&#x27;O&#x27;</span> || c == <span class="string">&#x27;U&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-验证回文字符串-II-力扣680"><a href="#3-验证回文字符串-II-力扣680" class="headerlink" title="3.验证回文字符串 II (力扣680)"></a>3.验证回文字符串 II (力扣680)</h2><p><img src="/images/leetcode680.png" alt="力扣680"></p>
<p>思路：</p>
<p>回文字符串判断，可以利用双指针一个指头，一个指尾，若相同则向中间移动；若不同按题意是需要删除一个字符，但实际并不需要删除只需移动指针继续判断是不是回文字符串即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = s.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//双指针循环找出不等于的字符索引</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; j &amp;&amp; <span class="keyword">char</span>[i] == <span class="keyword">char</span>[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除左边循环判断</span></span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(chars,i+<span class="number">1</span>,j)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//删除右边循环判断</span></span><br><span class="line">        <span class="keyword">if</span>(isPalindrome(chars,i,j-<span class="number">1</span>)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是不是回文字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(<span class="keyword">char</span>[] chars,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(chars[i++] != chars[j--]) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-合并两个有序数组-力扣88"><a href="#4-合并两个有序数组-力扣88" class="headerlink" title="4.合并两个有序数组(力扣88)"></a>4.合并两个有序数组(力扣88)</h2><p><img src="/images/leetcode88.png" alt="力扣88"></p>
<p>思路：</p>
<p>两个数组合并，且数组有序，利用双指针都指向各自数组的尾部，但还需一个额外指针指向nums1数组的实际尾部，两个尾部的数比较，谁大谁插入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tail = nums1.length-<span class="number">1</span>, p1 = m - <span class="number">1</span>, p2 = n -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//p2&gt;0 ，说明p2还存在数；p2=0，需要将p1中的数插入</span></span><br><span class="line">        <span class="keyword">while</span>(p2 &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 &lt; <span class="number">0</span> || nums1[p1] &lt;= nums2[p2])&#123;</span><br><span class="line">                nums[tail--] = nums2[p2--];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                nums[tail--] = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-环形链表-力扣141"><a href="#5-环形链表-力扣141" class="headerlink" title="5.环形链表(力扣141)"></a>5.环形链表(力扣141)</h2><p><img src="/images/leetcode141.png" alt="力扣141"></p>
<p>思路：</p>
<p>链表中是否存在环，可以利用快慢指针进行判断，也是双指针的一种，快慢指针的特点是当快指针指向尾部时，慢指针正好走到中间。若链表存在环则两个指针最终会相遇，若不存在环则快指针指向为空或者快指针的next为空</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        ListNode slow = head, fast = head.next;</span><br><span class="line">        <span class="keyword">while</span>(slow != fast)&#123;</span><br><span class="line">            <span class="comment">//链表中长度为奇数个fast.next == null 偶数个fast == null</span></span><br><span class="line">            <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本题还可用hashSet解，将链表进行遍历添加进set中，若存在环就会添加重复值，set无法添加重复值，这样就判断出链表是否存在环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(head.next != <span class="keyword">null</span>)&#123;<span class="comment">//不破坏head可以额外定义一个temp节点</span></span><br><span class="line">            <span class="keyword">if</span>(set.add(head)) head = head.next;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-平方数之和-力扣633"><a href="#6-平方数之和-力扣633" class="headerlink" title="6.平方数之和(力扣633)"></a>6.平方数之和(力扣633)</h2><p><img src="/images/leetcode633.png" alt="力扣633"></p>
<p>思路：</p>
<p>假设a,b两个数的平方等于c，设初始值a=0，b=根号c (两个指针)，若a，b两数平方之和等于c，则返回true；若小于c，则将a++；若大于则将b–；若a = b还未找到则结束查找，返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = (<span class="keyword">int</span>) Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= j)&#123;</span><br><span class="line">            <span class="keyword">int</span> num = i*i + j*j;</span><br><span class="line">            <span class="keyword">if</span>(num == c) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num &gt; c) j--;</span><br><span class="line">            <span class="keyword">else</span> (num &lt; c) i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数学解法——费马平方和：奇质数能表示为两个平方数之和的充分必要条件是该质数被4除余1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> base = <span class="number">2</span>; base * base &lt;= c; base++) &#123;</span><br><span class="line">            <span class="comment">// 如果不是因子，枚举下一个</span></span><br><span class="line">            <span class="keyword">if</span> (c % base != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算 base 的幂</span></span><br><span class="line">            <span class="keyword">int</span> exp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (c % base == <span class="number">0</span>) &#123;</span><br><span class="line">                c /= base;</span><br><span class="line">                exp++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据 Sum of two squares theorem 验证</span></span><br><span class="line">            <span class="keyword">if</span> (base % <span class="number">4</span> == <span class="number">3</span> &amp;&amp; exp % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	<span class="comment">// 例如 11 这样的用例，由于上面的 for 循环里 base * base &lt;= c ，base == 11 的时候不会进入循环体</span></span><br><span class="line">      	<span class="comment">// 因此在退出循环以后需要再做一次判断</span></span><br><span class="line">        <span class="keyword">return</span> c % <span class="number">4</span> != <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p><a href="https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/">二分查找精髓解析</a></p>
<h2 id="1-x的平方根-力扣69"><a href="#1-x的平方根-力扣69" class="headerlink" title="1.x的平方根(力扣69)"></a>1.x的平方根(力扣69)</h2><p><img src="/images/leetcode69.png" alt="力扣69"></p>
<p>思路：</p>
<p>由于 x 平方根的整数部分 ans 是满足 k^2  ≤x 的最大 k 值，因此我们可以对 k 进行二分查找，从而得到答案。二分查找的下界为 0，上界可以粗略地设定为 x。在二分查找的每一步中，我们只需要比较中间元素 mid 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = x, ans = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((<span class="keyword">long</span>)mid * mid &lt;= x)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数学解法——牛顿迭代法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> C = x, x0 = x;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">double</span> xi = <span class="number">0.5</span> * (x0 + C / x0);</span><br><span class="line">            <span class="keyword">if</span> (Math.abs(x0 - xi) &lt; <span class="number">1e-7</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            x0 = xi;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) x0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-寻找比目标字母大的最小字母-力扣744"><a href="#2-寻找比目标字母大的最小字母-力扣744" class="headerlink" title="2.寻找比目标字母大的最小字母(力扣744)"></a>2.寻找比目标字母大的最小字母(力扣744)</h2><p><img src="/images/leetcode744.png" alt="力扣744"></p>
<p>思路：</p>
<p>想要在有序数组中查找比目标字母大的最小字母，可以使用二分查找：找到 <code>target</code> 插入 <code>letters</code> 中的位置， 位置+1即为比target大的最小字母</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = letters.length, l = <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] &lt;= target)&#123;</span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left &lt; len ? letters[l] : letters[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线性扫描，逐一判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : letters)&#123;<span class="comment">//数组已排序，第一大于target的字符即为最小字符</span></span><br><span class="line">            <span class="keyword">if</span>(c &gt; target) <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letter[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-第一个错误版本-力扣278"><a href="#3-第一个错误版本-力扣278" class="headerlink" title="3.第一个错误版本(力扣278)"></a>3.第一个错误版本(力扣278)</h2><p><img src="/images/leetcode278.png" alt="力扣278"></p>
<p>思路：</p>
<p>使用二分查找寻找错误的版本，若当前版本是错误的那么这个版本之后的所有版本都为错，所以可以直接缩小搜索范围，即r = mid</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid))&#123;</span><br><span class="line">                r = mid;<span class="comment">//当前是错误版本，直接缩小范围</span></span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-有序数组中的单一元素-力扣540"><a href="#4-有序数组中的单一元素-力扣540" class="headerlink" title="4.有序数组中的单一元素(力扣540)"></a>4.有序数组中的单一元素(力扣540)</h2><p><img src="/images/leetcode540.png" alt="力扣540"></p>
<p>思路：</p>
<p>可以线性搜索数组中的每一个数，直到找到单个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i+=<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">//时间复杂度为O(n)不符合题目要求</span></span><br></pre></td></tr></table></figure>

<p>奇数长度的数组首尾元素索引都为偶数，因此我们可以将 l 和 r 设置为数组首尾。<br>我们需要确保 mid 是偶数，如果为奇数，则将其减 1。<br>然后，我们检查 mid 的元素是否与其后面的索引相同。<br>如果相同，则我们知道 mid 不是单个元素。且单个元素在 mid 之后。则我们将 l 设置为 mid + 2。<br>如果不是，则我们知道单个元素位于 mid，或者在 mid 之前。我们将 r 设置为 mid。<br>一旦 l == r，则当前搜索空间为 1 个元素，那么该元素为单个元素，我们将返回它</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r=  nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r-l)/<span class="number">2</span>;<span class="comment">//取mid数，下标为偶数</span></span><br><span class="line">            <span class="keyword">if</span>(l == r) <span class="keyword">return</span> nums[l];<span class="comment">//元素只有一个，已找到</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] % <span class="number">2</span> == <span class="number">1</span>) mid--;<span class="comment">//如果mid下标为奇数则将其-1</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid+<span class="number">1</span>]) l = mid + <span class="number">2</span>;<span class="comment">//若相等，则单元素在右边，l要往有移动2</span></span><br><span class="line">            <span class="keyword">else</span> r = mid;<span class="comment">//不相等，则说明单元素在左边，右边全是双元数，缩小范围</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-寻找旋转排序数组中的最小值-力扣153"><a href="#5-寻找旋转排序数组中的最小值-力扣153" class="headerlink" title="5.寻找旋转排序数组中的最小值(力扣153)"></a>5.寻找旋转排序数组中的最小值(力扣153)</h2><p><img src="/images/leetcode153.png" alt="力扣153"></p>
<p>思路：</p>
<p>暴力解法，直接调用api排序，返回第一个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nums数组本身是排好序的，由于进行了旋转，值小的数排到后面，根据这一点，只要旋转未旋转成原来排好序的数组，那么最左边的数一定大于最右边的数。要查询出数组中最小的值，这最小的数的前一个是必定大于该数的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;<span class="comment">//缩小范围，取中间值</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; nums[r]) r = mid;<span class="comment">//若最右值大于mid值说明最小值在mid的最左边</span></span><br><span class="line">            <span class="keyword">else</span> l =  mid + <span class="number">1</span>;<span class="comment">//反之最小值在mid值的右边进行mid+1判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当l = r时即找到该最小值</span></span><br><span class="line">         <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-在排序数组中查找元素的第一个和最后一个位置-力扣34"><a href="#6-在排序数组中查找元素的第一个和最后一个位置-力扣34" class="headerlink" title="6.在排序数组中查找元素的第一个和最后一个位置(力扣34)"></a>6.在排序数组中查找元素的第一个和最后一个位置(力扣34)</h2><p><img src="/images/leetcode34.png" alt="力扣34"></p>
<p>思路：</p>
<p>一个排好序的数组，查找树的位置，可用二分查找。要求查一个数的两个位置即开始位置和结束位置，那么需要两次二分查找，一个查询target，另一个查询target+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> f = find(nums,target);</span><br><span class="line">        <span class="keyword">int</span> l = find(nums,target+<span class="number">1</span>) - <span class="number">1</span>;<span class="comment">//查询的是target+1的下标所以要-1</span></span><br><span class="line">        <span class="comment">//数组为空或数组中未有该值</span></span><br><span class="line">        <span class="keyword">if</span>(f == nums.length || nums[f] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="comment">//target在数组中可能只存在一个，也可能多个，要进行max判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;f,Math.max(f,l)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//查询target在数组的开始位置即下标</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.length;<span class="comment">//这里未-1，防止死循环</span></span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) l = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="1-数组中第的K个最大元素-力扣215"><a href="#1-数组中第的K个最大元素-力扣215" class="headerlink" title="1.数组中第的K个最大元素(力扣215)"></a>1.数组中第的K个最大元素(力扣215)</h2><p><img src="/images/leetcode215.png" alt="力扣215"></p>
<p>思路：</p>
<p>暴力题解，调用api然后输出倒数第k个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用快速排序的性质：每一次都能排定一个元素，并且这个元素左边的数都不大于它，这个元素右边的数都不小于它，并且还能知道排定以后的元素的索引，所以不需要将整个数组进行排好序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        quickSort(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>,k);</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length-k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end,<span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> i =start, j =end, vot = nums[i];</span><br><span class="line">            <span class="keyword">while</span> (i != j)&#123;<span class="comment">//快排</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= vot) j--;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) nums[i++] = nums[j];</span><br><span class="line">                <span class="keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= vot) i++;</span><br><span class="line">                <span class="keyword">if</span> (i &lt; j) nums[j--] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[i] = vot;<span class="comment">//此时已经确定了一个数，即第i小的数</span></span><br><span class="line">            <span class="keyword">if</span> (i == nums.length - target)&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i &lt; nums.length - target)&#123;<span class="comment">//往左边查找</span></span><br><span class="line">                quickSort(nums, i+<span class="number">1</span>, end, target);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//往右边查找</span></span><br><span class="line">                quickSort(nums, start, i-<span class="number">1</span>, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-前K个高频元素-力扣347"><a href="#2-前K个高频元素-力扣347" class="headerlink" title="2.前K个高频元素(力扣347)"></a>2.前K个高频元素(力扣347)</h2><p><img src="/images/leetcode347.png" alt="力扣347"></p>
<p>思路：</p>
<p>算数组中某些数的出现次数，那就用hashMap记录每个数的出现次数，维护一个大小为k的最小堆，每次将新的元素与堆顶元素（堆中频率最小的元素）进行比较，如果新元素的频率更大，则弹出堆顶元素将新元素添加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最小堆</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))<span class="comment">//包含num</span></span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);<span class="comment">//将次数+1</span></span><br><span class="line">            <span class="keyword">else</span> map.put(num,<span class="number">1</span>);<span class="comment">//不包含则记录该数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; minHeap = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> map.get(o1) - map.get(o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;<span class="comment">//遍历map的key集合</span></span><br><span class="line">            <span class="keyword">if</span>(minHeap.size() &lt; k)&#123;<span class="comment">//minHeap还有空间添加key</span></span><br><span class="line">                minHeap.add(key);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(map.get(key) &gt; map.get(minHeap.peek()))&#123;<span class="comment">//当前值大于堆顶元素</span></span><br><span class="line">                minHeap.poll();<span class="comment">//弹出堆顶元素</span></span><br><span class="line">                minHeap.add(key);<span class="comment">//换为新元素</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//结果数组</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!minHeap.isEmpty())&#123;</span><br><span class="line">            res[i++] = minHeap.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以使用桶排序，首先依旧使用哈希表统计频率，统计完成后，创建一个数组，将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] topKFrequent(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        HashMap&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(map.containsKey(num))<span class="comment">//包含num</span></span><br><span class="line">                map.put(num,map.get(num)+<span class="number">1</span>);<span class="comment">//将次数+1</span></span><br><span class="line">            <span class="keyword">else</span> map.put(num,<span class="number">1</span>);<span class="comment">//不包含则记录该数</span></span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; buckets = <span class="keyword">new</span> ArrayList[nums.length+<span class="number">1</span>];<span class="comment">//建立桶</span></span><br><span class="line">        <span class="keyword">for</span>(Integer key : map.keySet())&#123;<span class="comment">//遍历map的key集合</span></span><br><span class="line">            <span class="keyword">int</span> val = map.get(key);<span class="comment">//获取键对应的值</span></span><br><span class="line">            <span class="keyword">if</span>(buckets[val] == <span class="keyword">null</span>)</span><br><span class="line">                buckets[val] = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            buckets[val].add(key);<span class="comment">//频率作为下标,值为元素的值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[k];<span class="comment">//结果数组</span></span><br><span class="line">        inr index = <span class="number">0</span>,len =  buckets.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =len- <span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;<span class="comment">//从尾部遍历</span></span><br><span class="line">            <span class="keyword">if</span>(buckets[i] != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; buckets[i].size() &amp;&amp; index &lt; k;j++)</span><br><span class="line">                    res[index++] = buckets[i].get(j);<span class="comment">//存入后k个数据</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-根据字符出现频率排序-力扣451"><a href="#3-根据字符出现频率排序-力扣451" class="headerlink" title="3.根据字符出现频率排序(力扣451)"></a>3.根据字符出现频率排序(力扣451)</h2><p><img src="/images/leetcode451.png" alt="力扣451"></p>
<p>思路：</p>
<p>统计每个字符频率使用一个辅助数组，按字符出现的频率降序排，可以想到使用大根堆来实现降序，不断取出堆顶元素，使用StringBuilder不断append即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此类问题也可以看作是查找问题, 从一个字符串中找出出现频率最高的字符, 然后将其排在最前面</span></span><br><span class="line">    <span class="comment">// 使用Java 提供的优先队列来按照出现次数进行排序</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span>[] helper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">128</span>];<span class="comment">//辅助数组，用来存储字符以及对应出现的次数</span></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="comment">//计算每个字符出现次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) helper[chars[i]]++;</span><br><span class="line">        <span class="comment">//大顶堆</span></span><br><span class="line">        PriorityQueue&lt;Character&gt; heap = <span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Character&gt;()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Character a,Character b)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> helper[b] - helper[a];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//将数据写入堆中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(helper[i] != <span class="number">0</span>)</span><br><span class="line">                heap.offer((<span class="keyword">char</span>)i);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(!heap.isEmpty())&#123;<span class="comment">//堆不为空，弹出每个字符</span></span><br><span class="line">            <span class="keyword">char</span> c = heap.poll();</span><br><span class="line">            <span class="keyword">while</span>(helper[c] &gt; <span class="number">0</span>)&#123;<span class="comment">//次数大于0</span></span><br><span class="line">                sb.append(c);</span><br><span class="line">                helper[c]--;<span class="comment">//次数-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用hashMap记录字符出现的频率，利用桶排序将频率作为桶的下标，然后从后往前遍历桶的集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="keyword">null</span> || s.length() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())&#123;</span><br><span class="line">            <span class="comment">// 填充 HashMap。如果当前 Key c 不存在，getOrDefault() 方法返回默认值 0；</span></span><br><span class="line">            <span class="comment">// 否则返回当前 Key c 对应的 Value。</span></span><br><span class="line">            <span class="comment">// 不管哪种情况最后都在 0 或者 Value 的基础上 +1。</span></span><br><span class="line">            map.put(c,map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建一系列桶，桶的个数为 s 的长度 +1，因为 buckets[0] 没有意义</span></span><br><span class="line">        List&lt;Character&gt;[] buckets = <span class="keyword">new</span> List[s.length() +<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 目的是将出现频率为 i 的字符放到第 i 个桶里（即 buckets[i]）</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> key : map.keySet)&#123;</span><br><span class="line">            <span class="keyword">int</span> val = map.get(key);<span class="comment">//获取键对应的值即字符出现的次数</span></span><br><span class="line">            <span class="keyword">if</span>(buckets[val] == <span class="keyword">null</span>)</span><br><span class="line">                buckets[val] = <span class="keyword">new</span> ArrayList&lt;Character&gt;();<span class="comment">//初始化一个数组</span></span><br><span class="line">            <span class="comment">// 某个字符在 HashMap 中的 Value 是几就会被放到第几个桶里</span></span><br><span class="line">            buckets[val].add(key);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="comment">//遍历每个桶，buckets.length-1为每个字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = buckets.length -<span class="number">1</span>;i &gt; <span class="number">0</span> ;i--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(buckets[i] != <span class="keyword">null</span>)&#123;<span class="comment">//桶中有字符</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c : buckets[i])&#123;<span class="comment">//遍历桶中的字符</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;<span class="number">0</span>; j--)&#123;</span><br><span class="line">                        <span class="comment">// 字符出现了几次就向 res 中添加几次该字符</span></span><br><span class="line">                        res.append(c);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-颜色分类-力扣75"><a href="#4-颜色分类-力扣75" class="headerlink" title="4.颜色分类(力扣75)"></a>4.颜色分类(力扣75)</h2><p><img src="/images/leetcode75.png" alt="力扣75"></p>
<p>思路：</p>
<p>直接调用api解，但明显没抓到题目的真正意图</p>
<p>单指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length,j = <span class="number">0</span>;<span class="comment">//初始化j，指向第一个元素</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = <span class="number">0</span>;</span><br><span class="line">                j++;<span class="comment">//指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = j; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = <span class="number">1</span>;</span><br><span class="line">                j++;<span class="comment">//指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>双指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">int</span> p1 = <span class="number">0</span>, p2 = len - <span class="number">1</span>;<span class="comment">//一个指头一个指尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= p2; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= p2 &amp;&amp; nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];<span class="comment">//将2移至尾部</span></span><br><span class="line">                nums[i] = nums[p2];</span><br><span class="line">                nums[p2] = temp;</span><br><span class="line">                p2--;<span class="comment">//指针前移</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];<span class="comment">//将0移至头部</span></span><br><span class="line">                nums[i] = nums[p1];</span><br><span class="line">                nums[p1] = temp;</span><br><span class="line">                p1++;<span class="comment">//指针后移</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这题虽然是排序，但是最优解法是用指针，指针的用法一般对于题目的约束比较大（只用关心较少的关键词）：比如两个数、三个数之和、平方之类，交换，环形，最长的之类的</p>
<p>排序的用法一般都比较简短，表达很简陋之类（考虑到所有数情况）：出现频率，第K大的数组。</p>
<h1 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h1><h2 id="1-为运算表达式设计优先级-力扣241"><a href="#1-为运算表达式设计优先级-力扣241" class="headerlink" title="1.为运算表达式设计优先级(力扣241)"></a>1.为运算表达式设计优先级(力扣241)</h2><p><img src="/images/leetcode241.png" alt="力扣241"></p>
<p>思路：</p>
<p>添加括号改变运算表达式运算的结果，仔细看示例，表达式中存在几个运算符那么就可以添加多少括号，将表达式分成两个部分，从运算符分割，算出每个子部分的所有可能值，然后将所有可能组合起来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">diffWaysToCompute</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//结果集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; expression.length(); i++)&#123;<span class="comment">//遍历表达式</span></span><br><span class="line">            <span class="comment">//若当前字符为数字则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(expression.charAt(i))) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">//递归将表达式分成两部分,递归函数传参传进来的是上一层左半部分或者右半部分</span></span><br><span class="line">            List&lt;Integer&gt; left = diffWaysToCompute(expression.substring(<span class="number">0</span>,i));</span><br><span class="line">            List&lt;Integer&gt; right = diffWaysToCompute(expression.substring(i+<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(Integer l : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(Integer r : right)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(expression.charAt(i) == <span class="string">&#x27;+&#x27;</span>) res.add(l + r);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(expression.charAt(i) == <span class="string">&#x27;-&#x27;</span>) res.add(l - r);</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(expression.charAt(i) == <span class="string">&#x27;*&#x27;</span>) res.add(l * r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//若表达式全为数字,将表达式放入res</span></span><br><span class="line">        <span class="keyword">if</span>(res.isEmpty()) res.add(Integer.parseInt(expression));</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-不同的二叉搜索数II-力扣95"><a href="#2-不同的二叉搜索数II-力扣95" class="headerlink" title="2.不同的二叉搜索数II(力扣95)"></a>2.不同的二叉搜索数II(力扣95)</h2><p><img src="/images/leetcode95.png" alt="力扣95"></p>
<p>思路：</p>
<p>构建不同的二叉搜索树需要将每一个节点都当作根节点，然后将该节点的左半部分和右半部分分别构建子树，并拼接到当前根节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> generateTrees(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        ListLinked&lt;TreeNode&gt; allTrees = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(start &gt; end)&#123;</span><br><span class="line">            allTrees.add(<span class="keyword">null</span>);<span class="comment">//生成空节点</span></span><br><span class="line">            <span class="keyword">return</span> allTress;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对每个值为i的根节点，其左右子树的根节点的值分别在[start, i - 1]和[i + 1, end]范围内</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="comment">//递归生成所有可能的二叉搜索左右子树</span></span><br><span class="line">            List&lt;TreeNode&gt; left = generateTrees(start,i-<span class="number">1</span>);</span><br><span class="line">            List&lt;TreeNode&gt; right = generateTrees(i+<span class="number">1</span>,end);</span><br><span class="line">             <span class="comment">//枚举所有左右子树的组合生成合法的二叉搜索树</span></span><br><span class="line">            <span class="keyword">for</span>(TreeNode l : left)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode r : right)&#123;</span><br><span class="line">                    <span class="comment">//拼接在根节点上</span></span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = l;</span><br><span class="line">                    root.right = r;</span><br><span class="line">                    allTrees.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> allTrees;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h1><p>dfs、bfs</p>
<h2 id="1-二进制矩阵中的最短路径-力扣1091"><a href="#1-二进制矩阵中的最短路径-力扣1091" class="headerlink" title="1.二进制矩阵中的最短路径(力扣1091)"></a>1.二进制矩阵中的最短路径(力扣1091)</h2><p><img src="/images/leetcode1091.png" alt="力扣1091"></p>
<p>思路：</p>
<p>寻出最短路径，首先起点和终点都可通才行，其次可以通过8个方向进行搜索路径即广度遍历，要得出下一个点的位置依赖于上一个点的位置即下个位置是在原位置上进行八个方向的遍历得出的，题目要求得最短路径，可以将到达这个点的步长记录下来</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> row,col;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] dir = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">0</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;-<span class="number">1</span>,<span class="number">1</span>&#125;&#125; <span class="comment">//八个方向</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">shortestPathBinaryMatrix</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        row = grid.length;<span class="comment">//行</span></span><br><span class="line">        col = grid[<span class="number">0</span>].length;<span class="comment">//列</span></span><br><span class="line">        <span class="keyword">if</span>(grid[<span class="number">0</span>][<span class="number">0</span>] == <span class="number">1</span> || grid[row-<span class="number">1</span>][col-<span class="number">1</span>] == <span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;<span class="comment">//起点和终点不可行</span></span><br><span class="line">        Queue&lt;<span class="keyword">int</span>[]&gt; pos = <span class="keyword">new</span> LinkedList&lt;&gt;();<span class="comment">//存储节点的位置</span></span><br><span class="line">        grid[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//到达起始点需要的步长</span></span><br><span class="line">        pos.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;);<span class="comment">//记录前一个节点得位置</span></span><br><span class="line">        <span class="keyword">while</span>(!pos.isEmpty() &amp;&amp; grid[row-<span class="number">1</span>][col-<span class="number">1</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span>[] xy = pos.remove();<span class="comment">//取出上一个节点的位置</span></span><br><span class="line">            <span class="keyword">int</span> preLength = grid[xy[<span class="number">0</span>]][xy[<span class="number">1</span>]];<span class="comment">//前一个节点的步长</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;<span class="comment">//八方向判断</span></span><br><span class="line">                <span class="keyword">int</span> newX = xy[<span class="number">0</span>] + dir[i][<span class="number">0</span>];<span class="comment">//新的x坐标</span></span><br><span class="line">                <span class="keyword">int</span> newY = xy[<span class="number">1</span>] + dir[i][<span class="number">1</span>];<span class="comment">//新的y坐标</span></span><br><span class="line">                <span class="comment">//未越界且节点未访问</span></span><br><span class="line">                <span class="keyword">if</span>(inGrid(newX.newY) &amp;&amp; grid[newX][newY] == <span class="number">0</span>)&#123;</span><br><span class="line">                    pos.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;newX,newY&#125;);<span class="comment">//记录该点的位置</span></span><br><span class="line">                    grid[newX][newY] = preLength+<span class="number">1</span>;<span class="comment">//该点的路径长度要+1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//终点若未访问即不可到达返回-1，访问了返回步长</span></span><br><span class="line">        <span class="keyword">return</span> grid[row-<span class="number">1</span>][col-<span class="number">1</span>] == <span class="number">0</span> ? -<span class="number">1</span> : grid[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断数组是否越界</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">inGrid</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; x &lt; row &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; col;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-完全平方数-力扣279"><a href="#2-完全平方数-力扣279" class="headerlink" title="2.完全平方数(力扣279)"></a>2.完全平方数(力扣279)</h2><p><img src="/images/leetcode279.png" alt="力扣279"></p>
<p>思路：</p>
<p>先枚举出所有小于n的平方数，用level记录几个平方数，然后将这些值与n比较，若相等直接返回level，小于则n减去该值直到n相等为止</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i*i &lt; n; i++)&#123;</span><br><span class="line">            list.add(i*i);<span class="comment">//找出所有小于n的平方数，bfs</span></span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; queue = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        queue.add(n);<span class="comment">//将n添加</span></span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;<span class="comment">//记录几个平方数</span></span><br><span class="line">        <span class="keyword">while</span>(queue.size() &gt; <span class="number">0</span>)&#123;<span class="comment">//若还有数</span></span><br><span class="line">            level++;</span><br><span class="line">            <span class="comment">//用set是因为在传递过程中两个值相减会存在相同的值</span></span><br><span class="line">            <span class="comment">//消除同一级别中的剩余项的冗余</span></span><br><span class="line">            Set&lt;Integer&gt; nextQueue = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : queue)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j : list)&#123;<span class="comment">//取出小于n的平方数</span></span><br><span class="line">                    <span class="keyword">if</span>(i.equals(j)) <span class="keyword">return</span> level;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(i &lt; j) <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">else</span> nextQueue.add(i-j);<span class="comment">//小于则相减将值传递下一次循环</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue = nextQueue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>动态规划解法,算n的平方根的最少数量，其实可以等于 i+前一个数的平方根最少数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSquares</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];<span class="comment">// 默认初始化值都为0</span></span><br><span class="line">        <span class="comment">//(1)遍历1~n</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//dp[i]=i这里做了两件事</span></span><br><span class="line">            <span class="comment">// 1. 初始化最小子问题，dp[1]=1,dp[2]=3,dp[3]=3</span></span><br><span class="line">            <span class="comment">// 2. 初始化最坏情况，每个整数都由n个1组成</span></span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="comment">//(2)动态保存最少数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">//状态选择：</span></span><br><span class="line">                <span class="comment">//选择目标：最少数量</span></span><br><span class="line">                <span class="comment">//选择列表：[小的完全平方数组成，大的完全平方数组成]</span></span><br><span class="line">                <span class="comment">//例如：12选择有[12-4+1=9，12-9+1=4，12-12+1=1]，当完全平方数j*j越大时越接近最优子问题</span></span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i - j * j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-岛屿的最大面积-力扣695"><a href="#3-岛屿的最大面积-力扣695" class="headerlink" title="3.岛屿的最大面积(力扣695)"></a>3.岛屿的最大面积(力扣695)</h2><p><img src="/images/leetcode695.png" alt="力扣695"></p>
<p>思路：</p>
<p>查询最大岛屿可以从四个方向查询即上下左右，可以用dfs也可以使用bfs。dfs：判断当前是不是岛屿，若是岛屿则将该岛屿沉没并num+1，然后递归搜索四个方向，注意越界问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>,m = grid.length,n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;<span class="comment">//遍历每一个岛屿</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)<span class="comment">//若是岛屿</span></span><br><span class="line">                    res = Math.max(res,dfs(i,j,grid));<span class="comment">//遍历最大岛屿面积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span>[][] grid)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt;<span class="number">0</span> || j &lt;<span class="number">0</span> || i &gt;= grid.length || j &gt;= grid[<span class="number">0</span>].length || grid[i][j] == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//防止越界</span></span><br><span class="line">        gird[i][j] = <span class="number">0</span>;<span class="comment">//沉没该岛屿</span></span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//四个方向进行判断</span></span><br><span class="line">        num += dfs(i+<span class="number">1</span>,j,grid);</span><br><span class="line">        num += dfs(i-<span class="number">1</span>,j,grid);</span><br><span class="line">        num += dfs(i,j+<span class="number">1</span>,grid);</span><br><span class="line">        num += dfs(i,j-<span class="number">1</span>,grid);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>bfs：遍历二维数组，对于每一块土地，也是去前后左右找相邻土地，只不过把找到的土地放到队列中<br>新土地加入队列的同时，岛屿面积area + 1，然后将该岛屿沉没</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, m = grid.length,n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i != m; i++)&#123;<span class="comment">//遍历每一个点</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j != n; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> cur = <span class="number">0</span>;<span class="comment">//记录岛屿面积</span></span><br><span class="line">                LinkedList&lt;Integer&gt; queue1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                LinkedList&lt;Integer&gt; queue2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">                queue1.offer(i);<span class="comment">//存入岛屿坐标</span></span><br><span class="line">                queue2.offer(j);</span><br><span class="line">                <span class="keyword">while</span>(!queue1.isEmpty())&#123;</span><br><span class="line">                    <span class="keyword">int</span> cur1 = queue1.poll(), cur2 = queue2,poll();</span><br><span class="line">                    <span class="keyword">if</span>(cu1&lt;<span class="number">0</span> || cur2&lt;<span class="number">0</span> || cur1==m || cur2==n || grid[cur1][cur2]!=<span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//越界直接跳出当前循环</span></span><br><span class="line">                    cur++;<span class="comment">//面积+1</span></span><br><span class="line">                    grid[cur1][cur2] = <span class="number">0</span>;<span class="comment">//沉没当前岛屿</span></span><br><span class="line">                    <span class="keyword">int</span>[] d1 = &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">                    <span class="keyword">int</span>[] d2 = &#123;<span class="number">1</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k != <span class="number">4</span>; k++)&#123;<span class="comment">//四个方向进行遍历</span></span><br><span class="line">                        <span class="keyword">int</span> next1 = cur1 + d1[k],next2 = cur2+d2[k];</span><br><span class="line">                        queue1.offer(next1);<span class="comment">//将下一个岛屿加入</span></span><br><span class="line">                        queue2.offer(next2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = Math.max(res,cur);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="4-太平洋大西洋水流问题-力扣417"><a href="#4-太平洋大西洋水流问题-力扣417" class="headerlink" title="4.太平洋大西洋水流问题(力扣417)"></a>4.太平洋大西洋水流问题(力扣417)</h2><p><img src="/images/leetcode417.png" alt="力扣417"></p>
<p>思路：</p>
<p>水往低处流，但是要找出最高点比较困难，可以反向操作，从低往高处搜索。从靠近大平洋的每一个点出发，搜索能逆流的点；从靠近大西洋的每一个点出发，搜索能逆流的点，若两个点的标记重合将该点返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pacificAtlantic(<span class="keyword">int</span>[][] heights) &#123;</span><br><span class="line">        <span class="keyword">if</span>(heights.length == <span class="number">0</span> || heights[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> m = heights.length,n = heights[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] pac = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];<span class="comment">//辅助数组，记录能从太平洋逆流的点</span></span><br><span class="line">        <span class="keyword">int</span>[][] atl = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];<span class="comment">//辅助数组，记录能从大西洋逆流的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i ==<span class="number">0</span> || j == <span class="number">0</span>)<span class="comment">//从太平洋出发</span></span><br><span class="line">                    dfs(heights,pac,i,j,heights[i][j]);</span><br><span class="line">                <span class="keyword">if</span>(i == m-<span class="number">1</span> || j == n-<span class="number">1</span>)<span class="comment">//从大西洋出发</span></span><br><span class="line">                    dfs(heights,atl,i,j,heights[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;m ;i++)&#123;<span class="comment">//遍历两个辅助数组</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pac[i][j] == <span class="number">1</span> &amp;&amp; atl[i][j] == <span class="number">1</span>)<span class="comment">//若该点都已标记即该点可达两洋</span></span><br><span class="line">                    res.add(Array.asList(i,j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原数组、辅助数组、起始坐标、起始坐标，前一个点的位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] matrix,<span class="keyword">int</span>[][] aux,<span class="keyword">int</span> i,<span class="keyword">int</span> j, <span class="keyword">int</span> pre)</span></span>&#123;</span><br><span class="line">        <span class="comment">//坐标越界、当前位置已被标记、当前位置的值小于前一个位置值</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || i&gt;matrix.length-<span class="number">1</span> || j &gt; matrix[<span class="number">0</span>].length-<span class="number">1</span> ||aux[i][j]==<span class="number">1</span> || matrix[i][j]&lt;pre) <span class="keyword">return</span>;</span><br><span class="line">        aux[i][j] = <span class="number">1</span>;<span class="comment">//标记该点，已遍历</span></span><br><span class="line">        dfs(matrix,aux,i-<span class="number">1</span>,j,matrix[i][j]);<span class="comment">//四方向遍历搜素</span></span><br><span class="line">        dfs(matrix,aux,i+<span class="number">1</span>,j,matrix[i][j]);</span><br><span class="line">        dfs(matrix,aux,i,j-<span class="number">1</span>,matrix[i][j]);</span><br><span class="line">        dfs(matrix,aux,i,j+<span class="number">1</span>,matrix[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="5-电话号码的字母组合-力扣17"><a href="#5-电话号码的字母组合-力扣17" class="headerlink" title="5.电话号码的字母组合(力扣17)"></a>5.电话号码的字母组合(力扣17)</h2><p><img src="/images/leetcode17.png" alt="力扣17"></p>
<p>思路：</p>
<p>首先构建一个dir包含数字对应的字母组合，遍历digits将其映射的字符组合起来，类似排列组合，但是遍历完一个字符后需要回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; res=  <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//数字对应的字母组合</span></span><br><span class="line">    <span class="keyword">private</span> String[] dir = &#123;<span class="string">&quot; &quot;</span>,<span class="string">&quot;*&quot;</span>,<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;def&quot;</span>,<span class="string">&quot;ghi&quot;</span>,<span class="string">&quot;jkl&quot;</span>,<span class="string">&quot;mno&quot;</span>,<span class="string">&quot;pqrs&quot;</span>,<span class="string">&quot;tuv&quot;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">letterCombinations</span><span class="params">(String digits)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(digits==<span class="keyword">null</span> || digits.length()==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//边界条件</span></span><br><span class="line">        goBack(digits,<span class="keyword">new</span> StringBuilder(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goBack</span><span class="params">(String str,StringBuilder letter,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == str.length)&#123;<span class="comment">//遍历完str的每一个字符跳出</span></span><br><span class="line">            res.add(letter.toString());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span> c = str.charAt(index);<span class="comment">//获取下标为index的字符</span></span><br><span class="line">        <span class="keyword">int</span> pos = c - <span class="string">&#x27;0&#x27;</span>;<span class="comment">//将char转化为int</span></span><br><span class="line">        String dirString = dir[pos];<span class="comment">//获取数字对应的字符集</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dirString.length(); i++)&#123;<span class="comment">//遍历当前字符集</span></span><br><span class="line">            letter.append(dirString.charAt(i));<span class="comment">//将当前字符组合</span></span><br><span class="line">            goBack(str,letter,index+<span class="number">1</span>);<span class="comment">//获取下一个字符</span></span><br><span class="line">            letter.deleteCharAt(letter.length()-<span class="number">1</span>);<span class="comment">//回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="6-复原IP地址-力扣93"><a href="#6-复原IP地址-力扣93" class="headerlink" title="6.复原IP地址(力扣93)"></a>6.复原IP地址(力扣93)</h2><p><img src="/images/leetcode93.png" alt="力扣93"></p>
<p>思路：</p>
<p>ip地址分为四段，最大为三位数即255，并且需要保证当前ip段的首字符不能为0，除非该段只有一位，分割出一段ip断后需要进行递归获取到后面的IP段，当ip段有四段且无字符剩余则将结果返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">restoreIpAddresses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; address = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        goBack(<span class="number">0</span>,sb,address,s);</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goBack</span><span class="params">(<span class="keyword">int</span> k,StringBuilder sb,List&lt;String&gt; address,String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">0</span> || k == <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="comment">//原字符串已经被分为四段且无字符剩余</span></span><br><span class="line">            <span class="keyword">if</span>(s.length() == <span class="number">0</span> &amp;&amp; k == <span class="number">4</span>)&#123;</span><br><span class="line">                address.add(sb.toString());<span class="comment">//将结果返回</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//跳出循环，进行回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最多获取三位字符</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length() &amp;&amp; i &lt;= <span class="number">2</span> ;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i != <span class="number">0</span> &amp;&amp; s.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//首字符为0直接跳出循环</span></span><br><span class="line">            String part = s.substring(<span class="number">0</span>,i+<span class="number">1</span>);<span class="comment">//分割字符</span></span><br><span class="line">            <span class="keyword">if</span>(Integer.parseInt(part) &lt;= <span class="number">255</span>)&#123;<span class="comment">//ip段最大为255</span></span><br><span class="line">                <span class="keyword">if</span>(sb.length() != <span class="number">0</span>)</span><br><span class="line">                    part = <span class="string">&#x27;.&#x27;</span> + part;<span class="comment">//存在ip段，后续ip段需加&#x27;.&#x27;隔开</span></span><br><span class="line">                sb.append(part);</span><br><span class="line">                goBack(k+<span class="number">1</span>,sb,address,s.substring(i+<span class="number">1</span>));</span><br><span class="line">                sb.delete(sb.length() - part.length(),sb.length);<span class="comment">//回溯</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="7-N皇后-力扣51"><a href="#7-N皇后-力扣51" class="headerlink" title="7.N皇后(力扣51)"></a>7.N皇后(力扣51)</h2><p><img src="/images/leetcode51.png" alt="力扣51"></p>
<p>思路：</p>
<p>解题关键在于判断棋盘上皇后是否冲突，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;List&lt;String&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[][] map;<span class="comment">//棋盘</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] nums;<span class="comment">//辅助数组,标志该列是否有皇后</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];<span class="comment">//初始化棋盘</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n ;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                map[i][j] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums = <span class="keyword">new</span> <span class="keyword">int</span>[n];<span class="comment">//初始化数组，设置每列都无皇后</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            nums[i] = -<span class="number">1</span>;</span><br><span class="line">        goBack(<span class="number">0</span>);<span class="comment">//递归解题</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">goBack</span><span class="params">(<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start == nums.length)&#123;<span class="comment">//棋盘每行都有皇后且不冲突</span></span><br><span class="line">            List&lt;String&gt; resTemp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="comment">//把map中的值，转变成字符串，并添加到结果中</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span>[] chars : map)</span><br><span class="line">                resTemp.add(<span class="keyword">new</span> String(chars));</span><br><span class="line">            res.add(resTemp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != -<span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//这一列是否有皇后，有则跳过</span></span><br><span class="line">            <span class="keyword">if</span>(!isValid(i,start)) <span class="keyword">continue</span>;<span class="comment">//判断斜方向是否有皇后</span></span><br><span class="line">            nums[i] = start;<span class="comment">//标志该位置，表示该列有皇后</span></span><br><span class="line">            map[start][i] = <span class="string">&#x27;Q&#x27;</span>;<span class="comment">//放皇后</span></span><br><span class="line">            goBack(start+<span class="number">1</span>);<span class="comment">//寻找下一个皇后的位置</span></span><br><span class="line">            nums[i] = -<span class="number">1</span>;<span class="comment">//回溯，将棋盘原模样进行还原</span></span><br><span class="line">            map[start][i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断当前位置是否可以放皇后</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> col,<span class="keyword">int</span> start)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == -<span class="number">1</span>) <span class="keyword">continue</span>;<span class="comment">//这一列无皇后，跳过</span></span><br><span class="line">            <span class="keyword">int</span> val = start - nums[i];<span class="comment">//计算两行的差值</span></span><br><span class="line">            <span class="keyword">int</span> diffVal = col - i;<span class="comment">//计算两列的差值</span></span><br><span class="line">            <span class="comment">//有可能为负值，将其转正</span></span><br><span class="line">            diffVal = diffVal &gt;= <span class="number">0</span> ? diffVal : -diffVal;</span><br><span class="line">            <span class="comment">//判断列之间的差值是否和层之间的差值相同，如是：则说明不能在当前位置放皇后</span></span><br><span class="line">            <span class="keyword">if</span>(val == diffVal) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="1-爬楼梯-力扣70"><a href="#1-爬楼梯-力扣70" class="headerlink" title="1.爬楼梯(力扣70)"></a>1.爬楼梯(力扣70)</h2><p><img src="/images/leetcode70.png" alt="力扣70"></p>
<p>思路：</p>
<p>本问题其实常规解法可以分成多个子问题，爬第n阶楼梯的方法数量，等于 2 部分之和</p>
<p>爬上 n−1 阶楼梯的方法数量。因为再爬1阶就能到第n阶<br>爬上 n−2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</p>
<p>转移方程:<code>f(x)=f(x−1)+f(x−2)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">int</span> pre1 = <span class="number">1</span>, pre2 = <span class="number">2</span>, cur;<span class="comment">//初始化上1台阶、2台阶的方法</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cur = pre1+pre2;<span class="comment">//前面上台阶的方法总和</span></span><br><span class="line">            pre1 = pre2;</span><br><span class="line">            pre2 = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-打家劫舍II-力扣213"><a href="#2-打家劫舍II-力扣213" class="headerlink" title="2.打家劫舍II(力扣213)"></a>2.打家劫舍II(力扣213)</h2><p><img src="/images/leetcode213.png" alt="力扣213"></p>
<p>思路：</p>
<p>偷取这条街只考虑当前能偷取的最大值，也就是在当前已经选好了偷取或不偷取的情况下的最大值，比如偷取前4户人家，先算第1户人家能偷取的最大值，在计算第2家能偷取的最大值，但是这第2家的值是与第1家进行比较，谁大即为谁的值，第3家是是取第1家的值加上当前值与第二家进行比较谁打即为谁值，以此类推得状态转移方程：<em>dp</em>[<em>i</em>]=max(<em>dp</em>[<em>i</em>−2]+<em>nums</em>[<em>i</em>],<em>dp</em>[<em>i</em>−1])</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> len = nums.length();</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];<span class="comment">//判断长度为1、2的情况</span></span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">2</span>) <span class="keyword">return</span> Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//因为首尾不能偷，所以有两种情况：偷头不偷尾、偷尾不偷头</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(robRange(nums,<span class="number">0</span>,len-<span class="number">2</span>),robRange(nums,<span class="number">1</span>,len-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">robRange</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = nums[start],second = nums[start+<span class="number">1</span>];<span class="comment">//偷取第1户、第2户的值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= end; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = second;</span><br><span class="line">            second = Math.max(first+nums[i],second);<span class="comment">//状态转移的体现</span></span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-不同路径-力扣62"><a href="#3-不同路径-力扣62" class="headerlink" title="3.不同路径(力扣62)"></a>3.不同路径(力扣62)</h2><p><img src="/images/leetcode62.png" alt="力扣62"></p>
<p>思路：</p>
<p>由于机器人每一步只能从向下或者向右移动一步，因此要想走到 (i,j)，如果向下走一步，那么会从 (i−1,j) 走过来；如果向右走一步，那么会从(i,j−1) 走过来。因此我们可以写出动态规划转移方程：</p>
<p><em>f(i, j) = f(i-1, j) + f(i, j-1)</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];<span class="comment">//初始化网格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) dp[i][<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//网格的最左边只能上往下，只有1种路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[<span class="number">0</span>][i] = <span class="number">1</span>;<span class="comment">//网格的最上边只能左往右，只有1种路径</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="comment">//网格其他点有两种到达方式</span></span><br><span class="line">                <span class="comment">//到达该点的路径等于上、左两点的路径总和</span></span><br><span class="line">                dp[i][j] = dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数学思路：</p>
<p>从左上角到右下角的过程中，我们需要移动 m+n−2 次，其中有 m−1 次向下移动，n−1 次向右移动。因此路径的总数，就等于从 m+n−2 次移动中选择 m−1 次向下移动的方案数，即组合数：</p>
<p><img src="/images/leetcode62diagram.png" alt="方程式"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = n, y = <span class="number">1</span>; y &lt; m; x++, y++) &#123;</span><br><span class="line">            res = res * x / y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-等差数列划分-力扣413"><a href="#4-等差数列划分-力扣413" class="headerlink" title="4.等差数列划分(力扣413)"></a>4.等差数列划分(力扣413)</h2><p><img src="/images/leetcode413.png" alt="力扣413"></p>
<p>思路：</p>
<p>等差数列的判断条件容易写出即<code>nums[i]-nums[i-1] == nums[i-1]-nums[i-2]</code>但是如何算出这个数列包含的所有等差数列呢？可以枚举数列个数比较少的情况看看是否能发现什么规律：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例： 1，2，3，4，5</span><br><span class="line">1.数列个数为3 -&gt; 等差数列个数为1  (1，2，3)</span><br><span class="line">2.数列个数为4 -&gt; 等差数列个数为3  (1，2，3，4)、(1，2，3)、(2，3，4)</span><br><span class="line">3.数列个数为5 -&gt; 等差数列个数为6	(1，2，3，4，5)、(1，2，3，4)、(2，3，4，5)、(1，2，3)、(2，3，4)、(3，4，5)</span><br><span class="line">. . .</span><br><span class="line">即个数为 n!</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> dp = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]-nums[i-<span class="number">1</span>] == nums[i-<span class="number">1</span>]-nums[i-<span class="number">2</span>])&#123;<span class="comment">//等差数列的判断条件</span></span><br><span class="line">                dp++;</span><br><span class="line">                sum+=dp;<span class="comment">//个数为n!</span></span><br><span class="line">            &#125;<span class="keyword">else</span> dp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-整数拆分-力扣343"><a href="#5-整数拆分-力扣343" class="headerlink" title="5.整数拆分(力扣343)"></a>5.整数拆分(力扣343)</h2><p><img src="/images/leetcode343.png" alt="力扣343"></p>
<p>思路：</p>
<p>对于的正整数 n，当 n≥2 时，可以拆分成至少两个正整数的和。令 kk 是拆分出的第一个正整数，则剩下的部分是 n−k，n−k 可以不继续拆分，或者继续拆分成至少两个正整数的和。由于每个正整数对应的最大乘积取决于比它小的正整数对应的最大乘积，因此可以使用动态规划求解:</p>
<p>一个数拆分几个数的和，计算这几个数的最大乘积，0、1不能拆分即dp[0]=dp[1]=0，但当i&gt;1</p>
<p>将 i 拆分成 j 和 i-j 的和，且 i-j 不再拆分成多个正整数，此时的乘积是 j×(i−j)；</p>
<p>将 i 拆分成 j 和 i-j的和，且 i-j 继续拆分成多个正整数，此时的乘积是 j ×{dp}[i-j]。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;<span class="comment">//从2开始，0、1不能拆分</span></span><br><span class="line">            <span class="keyword">int</span> curMax = <span class="number">0</span>;<span class="comment">//记录当前最大乘积</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                curMax = Math.max(curMax,Math.max(j*(i-j),j*dp[i-j]));</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = curMax;<span class="comment">//记录数为i的最大乘积</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-解码方法-力扣91"><a href="#6-解码方法-力扣91" class="headerlink" title="6.解码方法(力扣91)"></a>6.解码方法(力扣91)</h2><p><img src="/images/leetcode91.png" alt="力扣91"></p>
<p>思路：</p>
<p>定义dp[i]表示前i个字符的解码数。如果要求前i个字符的解码数</p>
<p>可以先求前i-1个字符的解码数，但前提条件是当前字符也可以解码（一个字符的话，只要不是0，都可以）<br>还可以求前i-2个字符的解码数，但前提条件是当前字符和前一个字符构成的两个数字是有效的</p>
<p>状态转移方程：<code>dp[i]=dp[i-1]+dp[i-2]</code>  需要根据不同情况进行讨论</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();<span class="comment">//获取字符串长度</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];<span class="comment">//初始化dp数组</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//空字符串可以有 1 种解码方法，解码出一个空字符串</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;<span class="comment">//从第二个字符开始</span></span><br><span class="line">            <span class="comment">//前一个字符值不为0</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) dp[i] += dp[i-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//解码个数为2且第一个字符不为‘0’且值小于等于26</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i-<span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp;</span><br><span class="line">              ((s.charAt(i-<span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> +(s.charAt(i-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>))</span><br><span class="line">                dp[i] += dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>斐波那契数列空间复杂度是可以优化的，只需要三个个变量即可，不需要申请一个数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numDecodings</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();<span class="comment">//获取字符串长度</span></span><br><span class="line">        <span class="comment">//lastL = dp[i-2],last = dp[i-1],cur = dp[i]</span></span><br><span class="line">        <span class="keyword">int</span> lastL = <span class="number">0</span>,last = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;<span class="comment">//从第二个字符开始</span></span><br><span class="line">            <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//前一个字符值不为0</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) != <span class="string">&#x27;0&#x27;</span>) cur += last;</span><br><span class="line">            <span class="comment">//解码个数为2且第一个字符不为‘0’且值小于等于26</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">1</span> &amp;&amp; s.charAt(i-<span class="number">2</span>) != <span class="string">&#x27;0&#x27;</span> &amp;&amp;</span><br><span class="line">              ((s.charAt(i-<span class="number">2</span>) - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> +(s.charAt(i-<span class="number">1</span>) - <span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">26</span>))</span><br><span class="line">                cur += lastL;</span><br><span class="line">            lastL = last;</span><br><span class="line">            last = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h1 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h1><h2 id="1-计数质数-力扣204"><a href="#1-计数质数-力扣204" class="headerlink" title="1.计数质数(力扣204)"></a>1.计数质数(力扣204)</h2><p><img src="/images/leetcode204" alt="力扣204"></p>
<p>思路：</p>
<p>暴力循环判断，双重for循环，判断哪些数无法被根号n的数整除。也可以反向思考，即埃氏筛选法</p>
<p>如果 x* 是质数，那么大于 x 的 x 的倍数 2x,3x,,… 一定不是质数，建立一个额外数组保存每个数是不是质数的布尔值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span>[] isPrime = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">       Arrays.fill(isPrime,<span class="keyword">true</span>);</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i*i &lt; n; i++)&#123;<span class="comment">//从2开始</span></span><br><span class="line">           <span class="keyword">if</span>(isPrime[i])&#123;<span class="comment">//如果没被标记过</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">int</span> j = i*i; i &lt; n; j+=i)&#123;</span><br><span class="line">                   isPrime[j] = <span class="keyword">false</span>;<span class="comment">//进行标记</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++)&#123;</span><br><span class="line">           <span class="keyword">if</span>(isPrime[i]) res++;<span class="comment">//统计质数的数量</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="2-七进制数-力扣504"><a href="#2-七进制数-力扣504" class="headerlink" title="2.七进制数(力扣504)"></a>2.七进制数(力扣504)</h2><p><img src="/images/leetcode504.png" alt="力扣504"></p>
<p>思路：</p>
<p>迭代除7取余，存到一个StringBuilder里，最后反转即可。对于负数，直接先取正处理，然后加上负号即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToBase7</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = num &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(flag) num = - num;<span class="comment">//将负数转正数</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(num%<span class="number">7</span>);</span><br><span class="line">            num/=<span class="number">7</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String res = sb.reverse().toString();<span class="comment">//结果反转</span></span><br><span class="line">        <span class="keyword">return</span> flag ? <span class="string">&quot;-&quot;</span>+res : res;<span class="comment">//如果为负数，结果前面加“-”</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-数字转换为十六进制数-力扣405"><a href="#3-数字转换为十六进制数-力扣405" class="headerlink" title="3.数字转换为十六进制数(力扣405)"></a>3.数字转换为十六进制数(力扣405)</h2><p><img src="/images/leetcode405.png" alt="力扣405"></p>
<p>思路：</p>
<p>首先建立一个字典保存十六进制的代表字符，然后获取num的后4位二进制数，即按位与num，之后逻辑右移4位，用&gt;&gt;&gt;=不考虑正负号，而&gt;&gt;=考虑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toHex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num == <span class="number">0</span>) <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;<span class="comment">//特殊情况</span></span><br><span class="line">        <span class="keyword">char</span>[] dir = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();<span class="comment">//数组映射</span></span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(num != <span class="number">0</span>)&#123;</span><br><span class="line">            sb.append(dir[num&amp;Ob1111]);<span class="comment">//取后4位二进制值对应dir表中的十六进制</span></span><br><span class="line">            num &gt;&gt;&gt;= <span class="number">4</span>;<span class="comment">//逻辑右移4位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();<span class="comment">//将结果反转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="4-阶乘后的零-力扣172"><a href="#4-阶乘后的零-力扣172" class="headerlink" title="4.阶乘后的零(力扣172)"></a>4.阶乘后的零(力扣172)</h2><p><img src="/images/leetcode172.png" alt="力扣172"></p>
<p>思路：</p>
<p>思考零是怎么来的，在乘法中，只有×5才可能会产生零，或者说阶乘中会有几个10产生就有几个零（2×5），从阶乘的定义来看，有几个5就会有几个2，所以统计时只需统计有几个5即可，举例5！=120、6！ =720、7！=5040、8！=40320 …注意是尾数为零，不是数中存在多少个零</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            n /= <span class="number">5</span>;</span><br><span class="line">            count += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="5-二进制求和-力扣67"><a href="#5-二进制求和-力扣67" class="headerlink" title="5.二进制求和(力扣67)"></a>5.二进制求和(力扣67)</h2><p><img src="/images/leetcode67.png" alt="力扣67"></p>
<p>思路：</p>
<p>简单思路：将二进制转化为十进制数后相加，之后再转化为二进制数，这个不贴代码了。</p>
<p>二进制数相加要从尾部开始，定义一个数存进位，若还有进位或者有数没加完都要继续循环进行相加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = a.length() -<span class="number">1</span> , j = b.length() - <span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(carry == <span class="number">1</span> || i &gt;= <span class="number">0</span> || j&gt;= <span class="number">0</span>)&#123;<span class="comment">//存在进位、字符串还有没遍历的</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; a.charAt(i--) == <span class="string">&#x27;1&#x27;</span>) carry++;<span class="comment">//记录该位置是否为1</span></span><br><span class="line">            <span class="keyword">if</span>(j &gt;= <span class="number">0</span> &amp;&amp; b.charAt(j--) == <span class="string">&#x27;1&#x27;</span>) carry++;<span class="comment">//同上</span></span><br><span class="line">            sb.append(carry % <span class="number">0b10</span>);<span class="comment">//0b10为十进制数2，进行取模</span></span><br><span class="line">            carry &gt;&gt;= <span class="number">1</span>;<span class="comment">//右移1位，也可写成carry/=2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();<span class="comment">//将结果进行反转</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个二进制数先进行相加直到有一方没有字符，后判断是哪个字符串有剩余，然后将该剩余值与carry相加即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addBinary</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = a.length()-<span class="number">1</span>,j = b.leangth()-<span class="number">1</span>,carry = <span class="number">0</span>;</span><br><span class="line">        StringBuilder sb = StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = carry;</span><br><span class="line">            sum += a.charAt(i--)-<span class="string">&#x27;0&#x27;</span>;<span class="comment">//转化为int以便两值相加</span></span><br><span class="line">            sum += b.cahrAt(j--)-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            carry = sum/<span class="number">2</span>;<span class="comment">//保存进位</span></span><br><span class="line">            sb.append(sum%<span class="number">2</span>);<span class="comment">//存值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)&#123;<span class="comment">//a字符串还有字符</span></span><br><span class="line">            <span class="keyword">int</span> sum = carry + a.charAt(i--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            carry = sum/<span class="number">2</span>;</span><br><span class="line">            sb.append(sum%<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)&#123;<span class="comment">//b字符串还有剩余</span></span><br><span class="line">            <span class="keyword">int</span> sum = carry + a.charAt(j--) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            carry = sum/<span class="number">2</span>;</span><br><span class="line">            sb.append(sum%<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) sb.append(carry);<span class="comment">//存在进位</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="6-有效的完全平方数-力扣367"><a href="#6-有效的完全平方数-力扣367" class="headerlink" title="6.有效的完全平方数(力扣367)"></a>6.有效的完全平方数(力扣367)</h2><p><img src="/images/leetcode367.png" alt="力扣367"></p>
<p>思路：</p>
<p>二分查找，左边界为2，有边界为num/2，当left &lt;= right，令x = left + (right-left)/2 即中间值，resNum = x*x，如果该值等于num即为true，大于将right-1，小于将left+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(num &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span>,right = num/<span class="number">2</span>,x,resNum;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            x = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">            resNum = x*x;</span><br><span class="line">            <span class="keyword">if</span>(resNum == num) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(resNum &gt; num) right = x - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="7-最少移动次数使数组元素相等II-力扣462"><a href="#7-最少移动次数使数组元素相等II-力扣462" class="headerlink" title="7.最少移动次数使数组元素相等II (力扣462)"></a>7.最少移动次数使数组元素相等II (力扣462)</h2><p><img src="/images/leetcode462.png" alt="力扣462"></p>
<p>思路：</p>
<p>将数组进行排序，获取中间数的值与其他所有数进行相减取绝对值即为移动次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minMoves2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : nums)&#123;</span><br><span class="line">            sum += Math.abs(nums[nums.length/<span class="number">2</span>]-num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外还可以借用快排解题，在一轮快速排序中，基准元素（pivot）的左侧有 p 个元素，右侧有 q 个元素，我们需要找第 k 小的元素。如果 k = p + 1，那么基准元素即为第 k 小的元素；如果 k &lt;= p，那么第 k 小的元素出现在左侧的 p 个元素中，因此我们并不需要对右侧的元素进行排序；如果 k &gt; p + 1，那么第 k 小的元素出现在右侧的 q 个元素中，因此我们并不需要对左侧的元素进行排序</p>
<h2 id="8-除自身以外数组的乘积-力扣238"><a href="#8-除自身以外数组的乘积-力扣238" class="headerlink" title="8.除自身以外数组的乘积(力扣238)"></a>8.除自身以外数组的乘积(力扣238)</h2><p><img src="/images/leetcode.png" alt="力扣238"></p>
<p>思路：</p>
<p>可以将乘积分为两部分即左边乘积和右边乘积，初始化res[0]=1，因为左边无数，右边同样如此</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;<span class="comment">//数组长度</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[len];<span class="comment">//结果数组</span></span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//下标为0的左边乘积，由于左边无数所以为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            <span class="comment">// res[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">            res[i] = res[i-<span class="number">1</span>]*nums[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="keyword">int</span> R = <span class="number">1</span>;<span class="comment">//下标为len-1的右边乘积，由于右边无数所以为1</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            res[i] = res[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">1</span>,right=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line">        <span class="comment">// 第一遍存i 左边所有结点的乘积;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">            res[i]=left;</span><br><span class="line">            left *=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第二遍倒序，计算当前i右边所有节点的乘积，</span></span><br><span class="line">        <span class="comment">// 调用之前计算的左边的乘积，并替换为左右乘积</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            res[i] *=right;</span><br><span class="line">            right *=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
        <tag>算法思想</tag>
      </tags>
  </entry>
</search>
